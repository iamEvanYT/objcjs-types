/**
 * Generates TypeScript declaration files from parsed ObjC class data.
 */

import type { ObjCClass, ObjCMethod } from "./ast-parser.ts";
import type { FrameworkConfig } from "./frameworks.ts";
import {
  selectorToJS,
  mapReturnType,
  mapParamType,
  STRUCT_TS_TYPES,
} from "./type-mapper.ts";

const AUTOGEN_HEADER = `// AUTO-GENERATED by objcjs-types generator — DO NOT EDIT`;

/**
 * Given an ObjCClass, determine which struct type names it references
 * (for import statements from ../structs.js).
 */
function collectReferencedStructs(cls: ObjCClass): Set<string> {
  const refs = new Set<string>();

  function extractStructRefs(typeStr: string): void {
    for (const structName of STRUCT_TS_TYPES) {
      // Match the struct name as a whole word in the mapped type string.
      // Struct types appear as bare names (e.g., "CGRect") or in union (e.g., "CGRect | null").
      if (typeStr === structName || typeStr.startsWith(structName + " ")) {
        refs.add(structName);
      }
    }
  }

  const allMethods = [...cls.instanceMethods, ...cls.classMethods];
  for (const method of allMethods) {
    extractStructRefs(mapReturnType(method.returnType, cls.name));
    for (const param of method.parameters) {
      extractStructRefs(mapParamType(param.type, cls.name));
    }
  }
  for (const prop of cls.properties) {
    extractStructRefs(mapReturnType(prop.type, cls.name));
    // Setter param uses mapParamType, same type
    extractStructRefs(mapParamType(prop.type, cls.name));
  }

  return refs;
}

/**
 * Given an ObjCClass, determine which other class names it references
 * (for import statements). Only includes classes we're generating.
 */
function collectReferencedClasses(
  cls: ObjCClass,
  allKnownClasses: Set<string>
): Set<string> {
  const refs = new Set<string>();

  // Superclass
  if (cls.superclass && allKnownClasses.has(cls.superclass)) {
    refs.add(cls.superclass);
  }

  function extractClassRefs(typeStr: string): void {
    // Find all _ClassName references that mapType would produce
    const regex = /_(\w+)/g;
    let match;
    while ((match = regex.exec(typeStr)) !== null) {
      const name = match[1]!;
      if (allKnownClasses.has(name) && name !== cls.name) {
        refs.add(name);
      }
    }
  }

  // Check all method signatures
  const allMethods = [...cls.instanceMethods, ...cls.classMethods];
  for (const method of allMethods) {
    const retType = mapReturnType(method.returnType, cls.name);
    extractClassRefs(retType);
    for (const param of method.parameters) {
      const pType = mapParamType(param.type, cls.name);
      extractClassRefs(pType);
    }
  }

  // Check properties
  for (const prop of cls.properties) {
    const pType = mapReturnType(prop.type, cls.name);
    extractClassRefs(pType);
  }

  // Remove self-reference
  refs.delete(cls.name);

  return refs;
}

/**
 * Determine which framework a referenced class belongs to.
 */
function getClassFramework(
  className: string,
  frameworks: FrameworkConfig[]
): string | null {
  for (const fw of frameworks) {
    if (fw.classes.includes(className)) {
      return fw.name;
    }
  }
  return null;
}

/**
 * Generate the method signature string for a single method.
 */
function emitMethodSignature(
  method: ObjCMethod,
  containingClass: string
): string | null {
  const jsName = selectorToJS(method.selector);
  const returnType = mapReturnType(method.returnType, containingClass);

  // Build parameter list
  const params: string[] = [];
  for (const param of method.parameters) {
    const tsType = mapParamType(param.type, containingClass);
    // Sanitize param name (avoid TS reserved words)
    const safeName = sanitizeParamName(param.name);
    params.push(`${safeName}: ${tsType}`);
  }

  const prefix = method.isClassMethod ? "static " : "";
  const deprecated = method.isDeprecated ? "  /** @deprecated */\n" : "";
  return `${deprecated}  ${prefix}${jsName}(${params.join(", ")}): ${returnType};`;
}

const TS_RESERVED = new Set([
  "break", "case", "catch", "continue", "debugger", "default", "delete",
  "do", "else", "finally", "for", "function", "if", "in", "instanceof",
  "new", "return", "switch", "this", "throw", "try", "typeof", "var",
  "void", "while", "with", "class", "const", "enum", "export", "extends",
  "import", "super", "implements", "interface", "let", "package", "private",
  "protected", "public", "static", "yield", "object", "string", "number",
  "boolean", "symbol", "any", "never", "unknown",
]);

function sanitizeParamName(name: string): string {
  if (TS_RESERVED.has(name)) return `${name}_`;
  if (!name || /^\d/.test(name)) return `arg`;
  return name;
}

/**
 * Generate a .ts file for a single ObjC class.
 */
export function emitClassFile(
  cls: ObjCClass,
  currentFramework: FrameworkConfig,
  allFrameworks: FrameworkConfig[],
  allKnownClasses: Set<string>,
  allParsedClasses?: Map<string, ObjCClass>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import type { NobjcObject } from "objc-js";`);

  // Collect referenced classes for imports
  const refs = collectReferencedClasses(cls, allKnownClasses);

  // Group refs by framework
  const importsByFramework = new Map<string, string[]>();
  for (const refClass of refs) {
    const fw = getClassFramework(refClass, allFrameworks);
    if (!fw) continue;
    if (!importsByFramework.has(fw)) {
      importsByFramework.set(fw, []);
    }
    importsByFramework.get(fw)!.push(refClass);
  }

  // Emit imports
  for (const [fwName, classes] of importsByFramework) {
    classes.sort();
    for (const refClass of classes) {
      if (fwName === currentFramework.name) {
        // Same framework - relative import
        lines.push(
          `import type { _${refClass} } from "./${refClass}.js";`
        );
      } else {
        // Different framework
        lines.push(
          `import type { _${refClass} } from "../${fwName}/${refClass}.js";`
        );
      }
    }
  }

  // Collect and emit struct type imports
  const structRefs = collectReferencedStructs(cls);
  if (structRefs.size > 0) {
    const sorted = [...structRefs].sort();
    lines.push(
      `import type { ${sorted.join(", ")} } from "../structs.js";`
    );
  }

  lines.push("");

  // Determine superclass type
  let superType: string;
  if (cls.superclass && allKnownClasses.has(cls.superclass)) {
    superType = `_${cls.superclass}`;
  } else {
    superType = "NobjcObject";
  }

  lines.push(`export declare class _${cls.name} extends ${superType} {`);

  // Emit instancetype overrides for alloc/new/init on subclasses.
  // In ObjC, these return `instancetype` (the calling class's type), but TypeScript
  // doesn't have polymorphic `this` for static methods. So we re-declare them on
  // every subclass to return the correct type.
  const selfType = `_${cls.name}`;
  const ownClassSelectors = new Set(cls.classMethods.map((m) => m.selector));
  const ownInstanceSelectors = new Set(cls.instanceMethods.map((m) => m.selector));

  if (cls.superclass) {
    const instancetypeOverrides: string[] = [];

    // static alloc() / static new() — only if not already declared on this class
    if (!ownClassSelectors.has("alloc")) {
      instancetypeOverrides.push(`  static alloc(): ${selfType};`);
    }
    if (!ownClassSelectors.has("new")) {
      instancetypeOverrides.push(`  static new(): ${selfType};`);
    }
    // init() — only if not already declared on this class
    if (!ownInstanceSelectors.has("init")) {
      instancetypeOverrides.push(`  init(): ${selfType};`);
    }

    if (instancetypeOverrides.length > 0) {
      for (const line of instancetypeOverrides) {
        lines.push(line);
      }
    }
  }

  // Build a set of parent member names with specific (non-NobjcObject) return types.
  // If a subclass redeclares a member returning NobjcObject when the parent has a
  // more specific type, we skip the override to avoid TypeScript assignment errors.
  const parentSpecificMembers = new Set<string>();
  if (allParsedClasses && cls.superclass) {
    let current = cls.superclass;
    while (current) {
      const parentCls = allParsedClasses.get(current);
      if (!parentCls) break;
      for (const prop of parentCls.properties) {
        const tsType = mapReturnType(prop.type, parentCls.name);
        if (tsType !== "NobjcObject") {
          parentSpecificMembers.add(prop.name);
        }
      }
      for (const method of [...parentCls.instanceMethods, ...parentCls.classMethods]) {
        const tsType = mapReturnType(method.returnType, parentCls.name);
        if (tsType !== "NobjcObject") {
          parentSpecificMembers.add(selectorToJS(method.selector));
        }
      }
      current = parentCls.superclass ?? "";
    }
  }

  function shouldSkipOverride(jsName: string, tsReturnType: string): boolean {
    return tsReturnType === "NobjcObject" && parentSpecificMembers.has(jsName);
  }

  // Split properties into class and instance
  const classProps = cls.properties.filter((p) => p.isClassProperty);
  const instanceProps = cls.properties.filter((p) => !p.isClassProperty);

  // Emit class methods (static), excluding class property accessors
  const classPropertyNames = new Set(classProps.map((p) => p.name));
  const classMethods = cls.classMethods.filter(
    (m) => !m.isDeprecated && !classPropertyNames.has(m.selector)
  );

  // Emit non-deprecated class properties (checking against class methods for deprecation)
  const allClassMethods = cls.classMethods;
  const nonDeprecatedClassProps = classProps.filter((p) => {
    const getter = allClassMethods.find((m) => m.selector === p.name);
    return !getter?.isDeprecated;
  });

  // Combine class methods and class properties into one "Class methods" section
  const hasClassSection = classMethods.length > 0 || nonDeprecatedClassProps.length > 0;
  if (hasClassSection) {
    lines.push("  // Class methods");
    for (const method of classMethods) {
      const jsName = selectorToJS(method.selector);
      const retType = mapReturnType(method.returnType, cls.name);
      if (shouldSkipOverride(jsName, retType)) continue;
      const sig = emitMethodSignature(method, cls.name);
      if (sig) lines.push(sig);
    }
    for (const prop of nonDeprecatedClassProps) {
      const tsType = mapReturnType(prop.type, cls.name);
      if (shouldSkipOverride(prop.name, tsType)) continue;
      lines.push(`  static ${prop.name}(): ${tsType};`);
      // Emit setter for readwrite class properties
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, cls.name);
        lines.push(`  static ${setterName}(value: ${paramType}): void;`);
      }
    }
  }

  // Emit instance methods
  const instanceMethods = cls.instanceMethods.filter((m) => !m.isDeprecated);

  // Separate instance properties from regular instance methods
  const instancePropertyNames = new Set(instanceProps.map((p) => p.name));

  // Methods that are NOT property accessors
  const regularMethods = instanceMethods.filter(
    (m) => !instancePropertyNames.has(m.selector)
  );

  if (regularMethods.length > 0) {
    if (hasClassSection) lines.push("");
    lines.push("  // Instance methods");
    for (const method of regularMethods) {
      const jsName = selectorToJS(method.selector);
      const retType = mapReturnType(method.returnType, cls.name);
      if (shouldSkipOverride(jsName, retType)) continue;
      const sig = emitMethodSignature(method, cls.name);
      if (sig) lines.push(sig);
    }
  }

  // Emit instance properties (as getter methods since that's how objc-js exposes them)
  const nonDeprecatedInstanceProps = instanceProps.filter((p) => {
    // Check if there's a corresponding method that's deprecated
    const getter = instanceMethods.find((m) => m.selector === p.name);
    return !getter?.isDeprecated;
  });

  if (nonDeprecatedInstanceProps.length > 0) {
    if (regularMethods.length > 0 || hasClassSection) lines.push("");
    lines.push("  // Properties");
    for (const prop of nonDeprecatedInstanceProps) {
      const tsType = mapReturnType(prop.type, cls.name);
      if (shouldSkipOverride(prop.name, tsType)) continue;
      lines.push(`  ${prop.name}(): ${tsType};`);
      // Emit setter for readwrite properties
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, cls.name);
        lines.push(`  ${setterName}(value: ${paramType}): void;`);
      }
    }
  }

  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate the barrel index.ts for a framework.
 */
export function emitFrameworkIndex(
  framework: FrameworkConfig,
  generatedClasses: string[]
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import { NobjcLibrary } from "objc-js";`);
  lines.push("");
  lines.push(
    `const ${framework.name} = new NobjcLibrary("${framework.libraryPath}");`
  );
  lines.push("");

  for (const className of generatedClasses) {
    lines.push(
      `import type { _${className} } from "./${className}.js";`
    );
    lines.push(
      `export const ${className} = ${framework.name}["${className}"] as unknown as typeof _${className};`
    );
    lines.push(`export type { _${className} };`);
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate the top-level src/index.ts barrel.
 */
export function emitTopLevelIndex(frameworkNames: string[]): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push("");

  lines.push(`export * from "./structs.js";`);
  for (const fw of frameworkNames) {
    lines.push(`export * from "./${fw}/index.js";`);
  }
  lines.push("");

  return lines.join("\n");
}
