/**
 * Generates TypeScript declaration files from parsed ObjC class data.
 */

import type { ObjCClass, ObjCMethod, ObjCProtocol } from "./ast-parser.ts";
import type { FrameworkConfig } from "./frameworks.ts";
import {
  selectorToJS,
  mapReturnType,
  mapParamType,
  STRUCT_TS_TYPES,
} from "./type-mapper.ts";

const AUTOGEN_HEADER = `// AUTO-GENERATED by objcjs-types generator — DO NOT EDIT`;

/**
 * Given an ObjCClass, determine which struct type names it references
 * (for import statements from ../structs.js).
 */
function collectReferencedStructs(cls: ObjCClass): Set<string> {
  const refs = new Set<string>();

  function extractStructRefs(typeStr: string): void {
    for (const structName of STRUCT_TS_TYPES) {
      // Match the struct name as a whole word in the mapped type string.
      // Struct types appear as bare names (e.g., "CGRect") or in union (e.g., "CGRect | null").
      if (typeStr === structName || typeStr.startsWith(structName + " ")) {
        refs.add(structName);
      }
    }
  }

  const allMethods = [...cls.instanceMethods, ...cls.classMethods];
  for (const method of allMethods) {
    extractStructRefs(mapReturnType(method.returnType, cls.name));
    for (const param of method.parameters) {
      extractStructRefs(mapParamType(param.type, cls.name));
    }
  }
  for (const prop of cls.properties) {
    extractStructRefs(mapReturnType(prop.type, cls.name));
    // Setter param uses mapParamType, same type
    extractStructRefs(mapParamType(prop.type, cls.name));
  }

  return refs;
}

/**
 * Given an ObjCClass, determine which other class names it references
 * (for import statements). Only includes classes we're generating.
 */
function collectReferencedClasses(
  cls: ObjCClass,
  allKnownClasses: Set<string>
): Set<string> {
  const refs = new Set<string>();

  // Superclass
  if (cls.superclass && allKnownClasses.has(cls.superclass)) {
    refs.add(cls.superclass);
  }

  function extractClassRefs(typeStr: string): void {
    // Find all _ClassName references that mapType would produce
    const regex = /_(\w+)/g;
    let match;
    while ((match = regex.exec(typeStr)) !== null) {
      const name = match[1]!;
      if (allKnownClasses.has(name) && name !== cls.name) {
        refs.add(name);
      }
    }
  }

  // Check all method signatures
  const allMethods = [...cls.instanceMethods, ...cls.classMethods];
  for (const method of allMethods) {
    const retType = mapReturnType(method.returnType, cls.name);
    extractClassRefs(retType);
    for (const param of method.parameters) {
      const pType = mapParamType(param.type, cls.name);
      extractClassRefs(pType);
    }
  }

  // Check properties
  for (const prop of cls.properties) {
    const pType = mapReturnType(prop.type, cls.name);
    extractClassRefs(pType);
  }

  // Remove self-reference
  refs.delete(cls.name);

  return refs;
}

/**
 * Determine which framework a referenced class belongs to.
 */
function getClassFramework(
  className: string,
  frameworks: FrameworkConfig[]
): string | null {
  for (const fw of frameworks) {
    if (fw.classes.includes(className)) {
      return fw.name;
    }
  }
  return null;
}

/**
 * Generate the method signature string for a single method.
 */
function emitMethodSignature(
  method: ObjCMethod,
  containingClass: string
): string | null {
  const jsName = selectorToJS(method.selector);
  const returnType = mapReturnType(method.returnType, containingClass);

  // Build parameter list
  const params: string[] = [];
  for (const param of method.parameters) {
    const tsType = mapParamType(param.type, containingClass);
    // Sanitize param name (avoid TS reserved words)
    const safeName = sanitizeParamName(param.name);
    params.push(`${safeName}: ${tsType}`);
  }

  const prefix = method.isClassMethod ? "static " : "";
  const deprecated = method.isDeprecated ? "  /** @deprecated */\n" : "";
  return `${deprecated}  ${prefix}${jsName}(${params.join(", ")}): ${returnType};`;
}

const TS_RESERVED = new Set([
  "break", "case", "catch", "continue", "debugger", "default", "delete",
  "do", "else", "finally", "for", "function", "if", "in", "instanceof",
  "new", "return", "switch", "this", "throw", "try", "typeof", "var",
  "void", "while", "with", "class", "const", "enum", "export", "extends",
  "import", "super", "implements", "interface", "let", "package", "private",
  "protected", "public", "static", "yield", "object", "string", "number",
  "boolean", "symbol", "any", "never", "unknown",
]);

function sanitizeParamName(name: string): string {
  if (TS_RESERVED.has(name)) return `${name}_`;
  if (!name || /^\d/.test(name)) return `arg`;
  return name;
}

/**
 * Generate a .ts file for a single ObjC class.
 */
export function emitClassFile(
  cls: ObjCClass,
  currentFramework: FrameworkConfig,
  allFrameworks: FrameworkConfig[],
  allKnownClasses: Set<string>,
  allParsedClasses?: Map<string, ObjCClass>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import type { NobjcObject } from "objc-js";`);

  // Collect referenced classes for imports
  const refs = collectReferencedClasses(cls, allKnownClasses);

  // Group refs by framework
  const importsByFramework = new Map<string, string[]>();
  for (const refClass of refs) {
    const fw = getClassFramework(refClass, allFrameworks);
    if (!fw) continue;
    if (!importsByFramework.has(fw)) {
      importsByFramework.set(fw, []);
    }
    importsByFramework.get(fw)!.push(refClass);
  }

  // Emit imports
  for (const [fwName, classes] of importsByFramework) {
    classes.sort();
    for (const refClass of classes) {
      if (fwName === currentFramework.name) {
        // Same framework - relative import
        lines.push(
          `import type { _${refClass} } from "./${refClass}.js";`
        );
      } else {
        // Different framework
        lines.push(
          `import type { _${refClass} } from "../${fwName}/${refClass}.js";`
        );
      }
    }
  }

  // Collect and emit struct type imports
  const structRefs = collectReferencedStructs(cls);
  if (structRefs.size > 0) {
    const sorted = [...structRefs].sort();
    lines.push(
      `import type { ${sorted.join(", ")} } from "../structs.js";`
    );
  }

  lines.push("");

  // Determine superclass type
  let superType: string;
  if (cls.superclass && allKnownClasses.has(cls.superclass)) {
    superType = `_${cls.superclass}`;
  } else {
    superType = "NobjcObject";
  }

  lines.push(`export declare class _${cls.name} extends ${superType} {`);

  // Emit instancetype overrides for alloc/new/init on subclasses.
  // In ObjC, these return `instancetype` (the calling class's type), but TypeScript
  // doesn't have polymorphic `this` for static methods. So we re-declare them on
  // every subclass to return the correct type.
  const selfType = `_${cls.name}`;
  const ownClassSelectors = new Set(cls.classMethods.map((m) => m.selector));
  const ownInstanceSelectors = new Set(cls.instanceMethods.map((m) => m.selector));

  if (cls.superclass) {
    const instancetypeOverrides: string[] = [];

    // static alloc() / static new() — only if not already declared on this class
    if (!ownClassSelectors.has("alloc")) {
      instancetypeOverrides.push(`  static alloc(): ${selfType};`);
    }
    if (!ownClassSelectors.has("new")) {
      instancetypeOverrides.push(`  static new(): ${selfType};`);
    }
    // init() — only if not already declared on this class
    if (!ownInstanceSelectors.has("init")) {
      instancetypeOverrides.push(`  init(): ${selfType};`);
    }

    if (instancetypeOverrides.length > 0) {
      for (const line of instancetypeOverrides) {
        lines.push(line);
      }
    }
  }

  // Build a map of parent member signatures (return type + param types) for override
  // conflict detection. TypeScript requires override compatibility:
  //   - Return types must be covariant (child return assignable to parent return)
  //   - Parameter types must be contravariant (parent params assignable to child params)
  // When the child's signature is incompatible, we skip the override entirely.
  interface ParentSig {
    returnType: string;
    paramTypes: string[];
  }
  const parentSignatures = new Map<string, ParentSig>();
  if (allParsedClasses && cls.superclass) {
    let current = cls.superclass;
    while (current) {
      const parentCls = allParsedClasses.get(current);
      if (!parentCls) break;
      for (const prop of parentCls.properties) {
        const tsType = mapReturnType(prop.type, parentCls.name);
        if (!parentSignatures.has(prop.name)) {
          parentSignatures.set(prop.name, { returnType: tsType, paramTypes: [] });
        }
        // Also track setter params for readwrite properties
        if (!prop.readonly) {
          const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
          if (!parentSignatures.has(setterName)) {
            const paramType = mapParamType(prop.type, parentCls.name);
            parentSignatures.set(setterName, { returnType: "void", paramTypes: [paramType] });
          }
        }
      }
      for (const method of [...parentCls.instanceMethods, ...parentCls.classMethods]) {
        const jsName = selectorToJS(method.selector);
        if (!parentSignatures.has(jsName)) {
          const retType = mapReturnType(method.returnType, parentCls.name);
          const paramTypes = method.parameters.map((p) => mapParamType(p.type, parentCls.name));
          parentSignatures.set(jsName, { returnType: retType, paramTypes });
        }
      }
      current = parentCls.superclass ?? "";
    }
  }

  /**
   * Check if a child method/property signature conflicts with its parent.
   * Returns true if the override should be skipped to avoid TS errors.
   */
  function shouldSkipOverride(jsName: string, tsReturnType: string, childParamTypes?: string[]): boolean {
    const parentSig = parentSignatures.get(jsName);
    if (!parentSig) return false;

    // Case 1: child returns NobjcObject but parent has a more specific type → skip
    if (tsReturnType === "NobjcObject" && parentSig.returnType !== "NobjcObject") {
      return true;
    }

    // Case 2: return type nullability conflict (child adds "| null" that parent doesn't have)
    if (tsReturnType.includes(" | null") && !parentSig.returnType.includes(" | null")) {
      return true;
    }

    // Case 3: parameter type conflicts
    if (childParamTypes && parentSig.paramTypes.length === childParamTypes.length) {
      for (let i = 0; i < childParamTypes.length; i++) {
        const childParam = childParamTypes[i]!;
        const parentParam = parentSig.paramTypes[i]!;
        if (childParam === parentParam) continue;
        // Any parameter type mismatch is a potential conflict — skip the override.
        // (Proper contravariance checking would be complex; simple inequality works here
        // because the generator already normalizes types consistently.)
        return true;
      }
    }

    return false;
  }

  // Split properties into class and instance
  const classProps = cls.properties.filter((p) => p.isClassProperty);
  const instanceProps = cls.properties.filter((p) => !p.isClassProperty);

  // Emit class methods (static), excluding class property accessors
  const classPropertyNames = new Set(classProps.map((p) => p.name));
  const classMethods = cls.classMethods.filter(
    (m) => !m.isDeprecated && !classPropertyNames.has(m.selector)
  );

  // Emit non-deprecated class properties (checking against class methods for deprecation)
  const allClassMethods = cls.classMethods;
  const nonDeprecatedClassProps = classProps.filter((p) => {
    const getter = allClassMethods.find((m) => m.selector === p.name);
    return !getter?.isDeprecated;
  });

  // Combine class methods and class properties into one "Class methods" section
  const hasClassSection = classMethods.length > 0 || nonDeprecatedClassProps.length > 0;
  if (hasClassSection) {
    lines.push("  // Class methods");
    for (const method of classMethods) {
      const jsName = selectorToJS(method.selector);
      const retType = mapReturnType(method.returnType, cls.name);
      const paramTypes = method.parameters.map((p) => mapParamType(p.type, cls.name));
      if (shouldSkipOverride(jsName, retType, paramTypes)) continue;
      const sig = emitMethodSignature(method, cls.name);
      if (sig) lines.push(sig);
    }
    for (const prop of nonDeprecatedClassProps) {
      const tsType = mapReturnType(prop.type, cls.name);
      if (shouldSkipOverride(prop.name, tsType, [])) continue;
      lines.push(`  static ${prop.name}(): ${tsType};`);
      // Emit setter for readwrite class properties
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, cls.name);
        if (!shouldSkipOverride(setterName, "void", [paramType])) {
          lines.push(`  static ${setterName}(value: ${paramType}): void;`);
        }
      }
    }
  }

  // Emit instance methods
  const instanceMethods = cls.instanceMethods.filter((m) => !m.isDeprecated);

  // Separate instance properties from regular instance methods
  const instancePropertyNames = new Set(instanceProps.map((p) => p.name));

  // Methods that are NOT property accessors
  const regularMethods = instanceMethods.filter(
    (m) => !instancePropertyNames.has(m.selector)
  );

  if (regularMethods.length > 0) {
    if (hasClassSection) lines.push("");
    lines.push("  // Instance methods");
    for (const method of regularMethods) {
      const jsName = selectorToJS(method.selector);
      const retType = mapReturnType(method.returnType, cls.name);
      const paramTypes = method.parameters.map((p) => mapParamType(p.type, cls.name));
      if (shouldSkipOverride(jsName, retType, paramTypes)) continue;
      const sig = emitMethodSignature(method, cls.name);
      if (sig) lines.push(sig);
    }
  }

  // Emit instance properties (as getter methods since that's how objc-js exposes them)
  const nonDeprecatedInstanceProps = instanceProps.filter((p) => {
    // Check if there's a corresponding method that's deprecated
    const getter = instanceMethods.find((m) => m.selector === p.name);
    return !getter?.isDeprecated;
  });

  if (nonDeprecatedInstanceProps.length > 0) {
    if (regularMethods.length > 0 || hasClassSection) lines.push("");
    lines.push("  // Properties");
    for (const prop of nonDeprecatedInstanceProps) {
      const tsType = mapReturnType(prop.type, cls.name);
      if (shouldSkipOverride(prop.name, tsType, [])) continue;
      lines.push(`  ${prop.name}(): ${tsType};`);
      // Emit setter for readwrite properties
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, cls.name);
        if (!shouldSkipOverride(setterName, "void", [paramType])) {
          lines.push(`  ${setterName}(value: ${paramType}): void;`);
        }
      }
    }
  }

  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

/**
 * Given an ObjCProtocol, determine which struct type names it references.
 */
function collectProtocolReferencedStructs(proto: ObjCProtocol): Set<string> {
  const refs = new Set<string>();

  function extractStructRefs(typeStr: string): void {
    for (const structName of STRUCT_TS_TYPES) {
      if (typeStr === structName || typeStr.startsWith(structName + " ")) {
        refs.add(structName);
      }
    }
  }

  const allMethods = [...proto.instanceMethods, ...proto.classMethods];
  for (const method of allMethods) {
    extractStructRefs(mapReturnType(method.returnType, proto.name));
    for (const param of method.parameters) {
      extractStructRefs(mapParamType(param.type, proto.name));
    }
  }
  for (const prop of proto.properties) {
    extractStructRefs(mapReturnType(prop.type, proto.name));
    extractStructRefs(mapParamType(prop.type, proto.name));
  }

  return refs;
}

/**
 * Given an ObjCProtocol, determine which other class names it references.
 */
function collectProtocolReferencedClasses(
  proto: ObjCProtocol,
  allKnownClasses: Set<string>
): Set<string> {
  const refs = new Set<string>();

  function extractClassRefs(typeStr: string): void {
    const regex = /_(\w+)/g;
    let match;
    while ((match = regex.exec(typeStr)) !== null) {
      const name = match[1]!;
      if (allKnownClasses.has(name)) {
        refs.add(name);
      }
    }
  }

  const allMethods = [...proto.instanceMethods, ...proto.classMethods];
  for (const method of allMethods) {
    const retType = mapReturnType(method.returnType, proto.name);
    extractClassRefs(retType);
    for (const param of method.parameters) {
      const pType = mapParamType(param.type, proto.name);
      extractClassRefs(pType);
    }
  }

  for (const prop of proto.properties) {
    const pType = mapReturnType(prop.type, proto.name);
    extractClassRefs(pType);
  }

  return refs;
}

/**
 * Generate a .ts file for a single ObjC protocol.
 * Protocols are emitted as TypeScript interfaces with optional methods,
 * representing the method map shape for NobjcProtocol.implement().
 */
export function emitProtocolFile(
  proto: ObjCProtocol,
  currentFramework: FrameworkConfig,
  allFrameworks: FrameworkConfig[],
  allKnownClasses: Set<string>,
  allKnownProtocols: Set<string>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import type { NobjcObject } from "objc-js";`);

  // Collect referenced classes for imports
  const refs = collectProtocolReferencedClasses(proto, allKnownClasses);

  // Group refs by framework
  const importsByFramework = new Map<string, string[]>();
  for (const refClass of refs) {
    const fw = getClassFramework(refClass, allFrameworks);
    if (!fw) continue;
    if (!importsByFramework.has(fw)) {
      importsByFramework.set(fw, []);
    }
    importsByFramework.get(fw)!.push(refClass);
  }

  // Emit class imports
  for (const [fwName, classes] of importsByFramework) {
    classes.sort();
    for (const refClass of classes) {
      if (fwName === currentFramework.name) {
        lines.push(
          `import type { _${refClass} } from "./${refClass}.js";`
        );
      } else {
        lines.push(
          `import type { _${refClass} } from "../${fwName}/${refClass}.js";`
        );
      }
    }
  }

  // Emit extended protocol imports
  for (const extProto of proto.extendedProtocols) {
    if (!allKnownProtocols.has(extProto)) continue;
    // Determine which framework the protocol belongs to
    const protoFw = getProtocolFramework(extProto, allFrameworks);
    if (!protoFw) continue;
    if (protoFw === currentFramework.name) {
      lines.push(
        `import type { _${extProto} } from "./${extProto}.js";`
      );
    } else {
      lines.push(
        `import type { _${extProto} } from "../${protoFw}/${extProto}.js";`
      );
    }
  }

  // Collect and emit struct type imports
  const structRefs = collectProtocolReferencedStructs(proto);
  if (structRefs.size > 0) {
    const sorted = [...structRefs].sort();
    lines.push(
      `import type { ${sorted.join(", ")} } from "../structs.js";`
    );
  }

  lines.push("");

  // Build extends clause from extended protocols we have types for
  const extendsClauses: string[] = [];
  for (const extProto of proto.extendedProtocols) {
    if (allKnownProtocols.has(extProto)) {
      extendsClauses.push(`_${extProto}`);
    }
  }
  const extendsStr = extendsClauses.length > 0
    ? ` extends ${extendsClauses.join(", ")}`
    : "";

  lines.push(`export interface _${proto.name}${extendsStr} {`);

  // Split properties into class and instance
  const instanceProps = proto.properties.filter((p) => !p.isClassProperty);

  // Emit instance methods (all optional with ? syntax)
  const instanceMethods = proto.instanceMethods.filter((m) => !m.isDeprecated);
  const instancePropertyNames = new Set(instanceProps.map((p) => p.name));
  const regularMethods = instanceMethods.filter(
    (m) => !instancePropertyNames.has(m.selector)
  );

  if (regularMethods.length > 0) {
    lines.push("  // Instance methods");
    for (const method of regularMethods) {
      const jsName = selectorToJS(method.selector);
      const returnType = mapReturnType(method.returnType, proto.name);
      const params: string[] = [];
      for (const param of method.parameters) {
        const tsType = mapParamType(param.type, proto.name);
        const safeName = sanitizeParamName(param.name);
        params.push(`${safeName}: ${tsType}`);
      }
      const deprecated = method.isDeprecated ? "  /** @deprecated */\n" : "";
      lines.push(`${deprecated}  ${jsName}?(${params.join(", ")}): ${returnType};`);
    }
  }

  // Emit instance properties (as optional getter methods)
  const nonDeprecatedInstanceProps = instanceProps.filter((p) => {
    const getter = instanceMethods.find((m) => m.selector === p.name);
    return !getter?.isDeprecated;
  });

  if (nonDeprecatedInstanceProps.length > 0) {
    if (regularMethods.length > 0) lines.push("");
    lines.push("  // Properties");
    for (const prop of nonDeprecatedInstanceProps) {
      const tsType = mapReturnType(prop.type, proto.name);
      lines.push(`  ${prop.name}?(): ${tsType};`);
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, proto.name);
        lines.push(`  ${setterName}?(value: ${paramType}): void;`);
      }
    }
  }

  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

/**
 * Determine which framework a protocol belongs to.
 */
function getProtocolFramework(
  protocolName: string,
  frameworks: FrameworkConfig[]
): string | null {
  for (const fw of frameworks) {
    if (fw.protocols?.includes(protocolName)) {
      return fw.name;
    }
  }
  return null;
}

// --- Struct definitions for code generation ---
// Each struct defines its TypeScript interface and factory function.
// Field info comes from the objc-js native bridge's KNOWN_STRUCT_FIELDS table
// (see struct-utils.h). Structs not in that table get positional names (field0, field1, ...).

interface StructFieldDef {
  name: string;
  type: string; // TypeScript type: "number" or a struct interface name
}

type StructDef = {
  /** The TypeScript interface/function name (e.g., "CGPoint") */
  tsName: string;
  /** Fields with their names and types */
  fields: StructFieldDef[];
  /** Factory function parameter list — for nested structs, these are flat params */
  factoryParams?: { name: string; type: string }[];
  /** Factory function body expression */
  factoryBody?: string;
} | {
  /** The TypeScript alias name (e.g., "NSPoint") */
  tsName: string;
  /** If this is an alias for another struct (e.g., NSPoint = CGPoint) */
  aliasOf: string;
};

/**
 * All struct definitions for src/structs.ts generation.
 * Order matters — dependencies must come before dependents.
 */
const STRUCT_DEFS: StructDef[] = [
  // --- Core Geometry ---
  {
    tsName: "CGPoint",
    fields: [
      { name: "x", type: "number" },
      { name: "y", type: "number" },
    ],
  },
  {
    tsName: "CGSize",
    fields: [
      { name: "width", type: "number" },
      { name: "height", type: "number" },
    ],
  },
  {
    tsName: "CGRect",
    fields: [
      { name: "origin", type: "CGPoint" },
      { name: "size", type: "CGSize" },
    ],
    factoryParams: [
      { name: "x", type: "number" },
      { name: "y", type: "number" },
      { name: "width", type: "number" },
      { name: "height", type: "number" },
    ],
    factoryBody: `{ origin: { x, y }, size: { width, height } }`,
  },
  {
    tsName: "CGVector",
    fields: [
      { name: "dx", type: "number" },
      { name: "dy", type: "number" },
    ],
  },
  // --- NS Aliases ---
  { tsName: "NSPoint", aliasOf: "CGPoint" },
  { tsName: "NSSize", aliasOf: "CGSize" },
  { tsName: "NSRect", aliasOf: "CGRect" },
  // --- Foundation Structs ---
  {
    tsName: "NSRange",
    fields: [
      { name: "location", type: "number" },
      { name: "length", type: "number" },
    ],
  },
  {
    tsName: "NSEdgeInsets",
    fields: [
      { name: "top", type: "number" },
      { name: "left", type: "number" },
      { name: "bottom", type: "number" },
      { name: "right", type: "number" },
    ],
  },
  {
    tsName: "NSDirectionalEdgeInsets",
    fields: [
      { name: "top", type: "number" },
      { name: "leading", type: "number" },
      { name: "bottom", type: "number" },
      { name: "trailing", type: "number" },
    ],
  },
  // --- Transforms ---
  {
    tsName: "CGAffineTransform",
    fields: [
      { name: "a", type: "number" },
      { name: "b", type: "number" },
      { name: "c", type: "number" },
      { name: "d", type: "number" },
      { name: "tx", type: "number" },
      { name: "ty", type: "number" },
    ],
  },
  // NSAffineTransformStruct is not in the objc-js known field table,
  // so the runtime uses positional names (field0, field1, ...).
  // The actual ObjC fields are: m11, m12, m21, m22, tX, tY.
  {
    tsName: "NSAffineTransformStruct",
    fields: [
      { name: "field0", type: "number" },
      { name: "field1", type: "number" },
      { name: "field2", type: "number" },
      { name: "field3", type: "number" },
      { name: "field4", type: "number" },
      { name: "field5", type: "number" },
    ],
  },
  // --- Structs not in objc-js known field table (positional names) ---
  // NSDecimal: ObjC struct with _exponent, _length, _isNegative, _isCompact, _reserved, _mantissa[8]
  // The runtime has no named fields for this, so it uses positional names.
  // However, it's a packed struct with bitfields — at the JS level it surfaces as positional fields.
  {
    tsName: "NSDecimal",
    fields: [
      { name: "field0", type: "number" },
      { name: "field1", type: "number" },
      { name: "field2", type: "number" },
      { name: "field3", type: "number" },
      { name: "field4", type: "number" },
      { name: "field5", type: "number" },
      { name: "field6", type: "number" },
      { name: "field7", type: "number" },
    ],
  },
  {
    tsName: "NSOperatingSystemVersion",
    fields: [
      { name: "field0", type: "number" },
      { name: "field1", type: "number" },
      { name: "field2", type: "number" },
    ],
  },
];

/**
 * Generate the src/structs.ts file with all struct interface + factory function definitions.
 */
export function emitStructsFile(): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`// Struct type definitions and factory functions for objc-js.`);
  lines.push(`// These match the field names produced by the objc-js native bridge.`);

  let lastSection = "";

  for (const def of STRUCT_DEFS) {
    const isAlias = "aliasOf" in def;

    // Determine section for comment headers
    const section = isAlias ? "alias"
      : def.tsName === "CGAffineTransform" || def.tsName === "NSAffineTransformStruct" ? "Transforms"
      : def.tsName.startsWith("CG") ? "CoreGraphics"
      : def.tsName === "NSRange" || def.tsName === "NSEdgeInsets" || def.tsName === "NSDirectionalEdgeInsets" ? "Foundation"
      : "Other";

    // Emit section headers
    if (section !== lastSection && !isAlias) {
      lines.push("");
      if (section === "CoreGraphics") lines.push("// --- Core Geometry ---");
      else if (section === "Foundation") lines.push("// --- Foundation Structs ---");
      else if (section === "Transforms") lines.push("// --- Transforms ---");
      else if (section === "Other") lines.push("// --- Other Structs (positional field names) ---");
      lastSection = section;
    }

    if (isAlias) {
      // Alias: emit type + const
      if (def.tsName === "NSPoint") {
        // Start NS aliases section
        lines.push("");
        lines.push("// --- NS Aliases (identical layout to CG counterparts) ---");
      }
      lines.push("");
      lines.push(`export type ${def.tsName} = ${def.aliasOf};`);
      lines.push(`export const ${def.tsName} = ${def.aliasOf};`);
      continue;
    }

    // Interface
    lines.push("");
    lines.push(`export interface ${def.tsName} {`);
    for (const field of def.fields) {
      lines.push(`  ${field.name}: ${field.type};`);
    }
    lines.push(`}`);

    // Factory function
    const params = def.factoryParams ?? def.fields.map((f) => ({ name: f.name, type: f.type }));
    const paramStr = params.map((p) => `${p.name}: ${p.type}`).join(", ");

    // For struct fields that reference other struct types, the factory needs
    // special handling. If factoryBody is provided, use it; otherwise generate
    // a simple object literal from the fields.
    const body = def.factoryBody ?? `{ ${def.fields.map((f) => f.name).join(", ")} }`;

    lines.push("");
    lines.push(`export function ${def.tsName}(${paramStr}): ${def.tsName} {`);
    lines.push(`  return ${body};`);
    lines.push(`}`);
  }

  lines.push("");

  return lines.join("\n");
}

/**
 * Generate the barrel index.ts for a framework.
 */
export function emitFrameworkIndex(
  framework: FrameworkConfig,
  generatedClasses: string[],
  generatedProtocols?: string[]
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import { NobjcLibrary } from "objc-js";`);
  lines.push("");
  lines.push(
    `const ${framework.name} = new NobjcLibrary("${framework.libraryPath}");`
  );
  lines.push("");

  for (const className of generatedClasses) {
    lines.push(
      `import type { _${className} } from "./${className}.js";`
    );
    lines.push(
      `export const ${className} = ${framework.name}["${className}"] as unknown as typeof _${className};`
    );
    lines.push(`export type { _${className} };`);
    lines.push("");
  }

  // Export protocol types (type-only, no runtime value)
  if (generatedProtocols && generatedProtocols.length > 0) {
    for (const protoName of generatedProtocols) {
      lines.push(
        `import type { _${protoName} } from "./${protoName}.js";`
      );
      lines.push(`export type { _${protoName} };`);
      lines.push("");
    }
  }

  return lines.join("\n");
}

/**
 * Generate the top-level src/index.ts barrel.
 */
export function emitTopLevelIndex(frameworkNames: string[]): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push("");

  lines.push(`export * from "./structs.js";`);
  for (const fw of frameworkNames) {
    lines.push(`export * from "./${fw}/index.js";`);
  }
  lines.push(`export { createDelegate } from "./delegates.js";`);
  lines.push(`export type { ProtocolMap } from "./delegates.js";`);
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate src/delegates.ts — a ProtocolMap interface mapping ObjC protocol
 * name strings to their TypeScript interface types, plus a type-safe
 * createDelegate() wrapper around NobjcProtocol.implement().
 */
export function emitDelegatesFile(
  frameworks: FrameworkConfig[],
  generatedProtocolsByFramework: Map<string, string[]>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import { NobjcProtocol } from "objc-js";`);
  lines.push(`import type { NobjcObject } from "objc-js";`);
  lines.push("");

  // Collect all generated protocols with their framework for imports
  const allProtocols: { name: string; framework: string }[] = [];
  for (const fw of frameworks) {
    const generated = generatedProtocolsByFramework.get(fw.name) ?? [];
    for (const name of generated) {
      allProtocols.push({ name, framework: fw.name });
    }
  }

  // Sort for deterministic output
  allProtocols.sort((a, b) => a.name.localeCompare(b.name));

  // Emit imports
  for (const proto of allProtocols) {
    lines.push(
      `import type { _${proto.name} } from "./${proto.framework}/${proto.name}.js";`
    );
  }
  lines.push("");

  // Emit ProtocolMap interface
  lines.push(`/** Maps ObjC protocol name strings to their TypeScript interface types. */`);
  lines.push(`export interface ProtocolMap {`);
  for (const proto of allProtocols) {
    lines.push(`  ${proto.name}: _${proto.name};`);
  }
  lines.push(`}`);
  lines.push("");

  // Emit createDelegate function
  lines.push(`/**`);
  lines.push(` * Create a type-safe Objective-C delegate object.`);
  lines.push(` *`);
  lines.push(` * Wraps NobjcProtocol.implement() with full type inference —`);
  lines.push(` * method names, parameter types, and return types are all inferred`);
  lines.push(` * from the protocol name string.`);
  lines.push(` *`);
  lines.push(` * @example`);
  lines.push(` * const delegate = createDelegate("NSWindowDelegate", {`);
  lines.push(` *   windowDidResize$(notification) {`);
  lines.push(` *     console.log("Window resized!");`);
  lines.push(` *   },`);
  lines.push(` * });`);
  lines.push(` */`);
  lines.push(`export function createDelegate<K extends keyof ProtocolMap>(`);
  lines.push(`  protocolName: K,`);
  lines.push(`  methods: Partial<ProtocolMap[K]>,`);
  lines.push(`): NobjcObject {`);
  lines.push(`  return NobjcProtocol.implement(`);
  lines.push(`    protocolName,`);
  lines.push(`    methods as Record<string, (...args: any[]) => any>,`);
  lines.push(`  );`);
  lines.push(`}`);
  lines.push("");

  return lines.join("\n");
}
