/**
 * Generates TypeScript declaration files from parsed ObjC class data.
 */

import type { ObjCClass, ObjCMethod, ObjCProperty, ObjCProtocol } from "./ast-parser.ts";
import type { FrameworkConfig } from "./frameworks.ts";
import {
  selectorToJS,
  mapReturnType,
  mapParamType,
  STRUCT_TS_TYPES,
} from "./type-mapper.ts";

const AUTOGEN_HEADER = `// AUTO-GENERATED by objcjs-types generator — DO NOT EDIT`;

/**
 * Group class names that would collide on a case-insensitive filesystem.
 * Returns a Map from the canonical filename (the name that survives — last in
 * sorted order, since classes are emitted alphabetically and the last write wins)
 * to the list of all class names that share that filename.
 *
 * Only groups with 2+ members represent actual collisions.
 */
export function groupCaseCollisions(classNames: string[]): Map<string, string[]> {
  // Group by lowercased name
  const byLower = new Map<string, string[]>();
  for (const name of classNames) {
    const key = name.toLowerCase();
    if (!byLower.has(key)) {
      byLower.set(key, []);
    }
    byLower.get(key)!.push(name);
  }

  const result = new Map<string, string[]>();
  for (const group of byLower.values()) {
    if (group.length < 2) continue;
    // Sort so the "canonical" name (last write on disk) is deterministic.
    // Classes are emitted in sorted order, so the last one in sort order is the survivor.
    group.sort();
    const canonical = group[group.length - 1]!;
    result.set(canonical, group);
  }
  return result;
}

/**
 * Given an ObjCClass, determine which struct type names it references
 * (for import statements from ../structs.js).
 */
function collectReferencedStructs(cls: ObjCClass): Set<string> {
  const refs = new Set<string>();

  function extractStructRefs(typeStr: string): void {
    for (const structName of STRUCT_TS_TYPES) {
      // Match the struct name as a whole word in the mapped type string.
      // Struct types appear as bare names (e.g., "CGRect") or in union (e.g., "CGRect | null").
      if (typeStr === structName || typeStr.startsWith(structName + " ")) {
        refs.add(structName);
      }
    }
  }

  const allMethods = [...cls.instanceMethods, ...cls.classMethods];
  for (const method of allMethods) {
    extractStructRefs(mapReturnType(method.returnType, cls.name));
    for (const param of method.parameters) {
      extractStructRefs(mapParamType(param.type, cls.name));
    }
  }
  for (const prop of cls.properties) {
    extractStructRefs(mapReturnType(prop.type, cls.name));
    // Setter param uses mapParamType, same type
    extractStructRefs(mapParamType(prop.type, cls.name));
  }

  return refs;
}

/**
 * Given an ObjCClass, determine which other class/protocol names it references
 * (for import statements). Only includes classes/protocols we're generating.
 */
function collectReferencedClasses(
  cls: ObjCClass,
  allKnownClasses: Set<string>,
  allKnownProtocols?: Set<string>
): Set<string> {
  const refs = new Set<string>();

  // Superclass
  if (cls.superclass && allKnownClasses.has(cls.superclass)) {
    refs.add(cls.superclass);
  }

  function extractClassRefs(typeStr: string): void {
    // Find all _ClassName references that mapType would produce
    const regex = /_(\w+)/g;
    let match;
    while ((match = regex.exec(typeStr)) !== null) {
      const name = match[1]!;
      if (name === cls.name) continue;
      if (allKnownClasses.has(name) || allKnownProtocols?.has(name)) {
        refs.add(name);
      }
    }
  }

  // Check all method signatures
  const allMethods = [...cls.instanceMethods, ...cls.classMethods];
  for (const method of allMethods) {
    const retType = mapReturnType(method.returnType, cls.name);
    extractClassRefs(retType);
    for (const param of method.parameters) {
      const pType = mapParamType(param.type, cls.name);
      extractClassRefs(pType);
    }
  }

  // Check properties
  for (const prop of cls.properties) {
    const pType = mapReturnType(prop.type, cls.name);
    extractClassRefs(pType);
  }

  // Remove self-reference
  refs.delete(cls.name);

  return refs;
}

/**
 * Determine which framework a referenced class belongs to.
 */
function getClassFramework(
  className: string,
  frameworks: FrameworkConfig[]
): string | null {
  for (const fw of frameworks) {
    if (fw.classes.includes(className)) {
      return fw.name;
    }
  }
  return null;
}

/**
 * Determine which framework a class or protocol belongs to.
 * Checks classes first, then protocols.
 */
function getEntityFramework(
  name: string,
  frameworks: FrameworkConfig[]
): string | null {
  for (const fw of frameworks) {
    if (fw.classes.includes(name)) {
      return fw.name;
    }
  }
  for (const fw of frameworks) {
    if (fw.protocols?.includes(name)) {
      return fw.name;
    }
  }
  return null;
}

/**
 * Build a JSDoc comment block from a description and/or deprecation info.
 * Returns an array of lines (without trailing newline) or empty array.
 */
function buildJSDoc(opts: {
  description?: string;
  isDeprecated?: boolean;
  deprecationMessage?: string;
  indent?: string;
}): string[] {
  const { description, isDeprecated, deprecationMessage, indent = "  " } = opts;
  if (!description && !isDeprecated) return [];

  const parts: string[] = [];
  if (description) {
    // Strip any embedded "*/" that would prematurely close the JSDoc comment
    parts.push(description.replace(/\*\//g, "").trim());
  }
  if (isDeprecated) {
    parts.push(deprecationMessage ? `@deprecated ${deprecationMessage}` : "@deprecated");
  }

  // Single-line JSDoc for short content
  if (parts.length === 1 && parts[0]!.length < 80) {
    return [`${indent}/** ${parts[0]} */`];
  }

  // Multi-line JSDoc
  const lines: string[] = [];
  lines.push(`${indent}/**`);
  for (let i = 0; i < parts.length; i++) {
    if (i > 0 && parts[i - 1] !== "" && !parts[i]!.startsWith("@")) {
      lines.push(`${indent} *`);
    }
    lines.push(`${indent} * ${parts[i]}`);
  }
  lines.push(`${indent} */`);
  return lines;
}

/**
 * Generate the method signature string for a single method.
 */
function emitMethodSignature(
  method: ObjCMethod,
  containingClass: string
): string | null {
  const jsName = selectorToJS(method.selector);
  const returnType = mapReturnType(method.returnType, containingClass);

  // Build parameter list
  const params: string[] = [];
  for (const param of method.parameters) {
    const tsType = mapParamType(param.type, containingClass);
    // Sanitize param name (avoid TS reserved words)
    const safeName = sanitizeParamName(param.name);
    params.push(`${safeName}: ${tsType}`);
  }

  const prefix = method.isClassMethod ? "static " : "";
  const jsdoc = buildJSDoc({
    description: method.description,
    isDeprecated: method.isDeprecated,
    deprecationMessage: method.deprecationMessage,
  });
  const jsdocStr = jsdoc.length > 0 ? jsdoc.join("\n") + "\n" : "";
  return `${jsdocStr}  ${prefix}${jsName}(${params.join(", ")}): ${returnType};`;
}

const TS_RESERVED = new Set([
  "break", "case", "catch", "continue", "debugger", "default", "delete",
  "do", "else", "finally", "for", "function", "if", "in", "instanceof",
  "new", "return", "switch", "this", "throw", "try", "typeof", "var",
  "void", "while", "with", "class", "const", "enum", "export", "extends",
  "import", "super", "implements", "interface", "let", "package", "private",
  "protected", "public", "static", "yield", "object", "string", "number",
  "boolean", "symbol", "any", "never", "unknown",
]);

function sanitizeParamName(name: string): string {
  if (TS_RESERVED.has(name)) return `${name}_`;
  if (!name || /^\d/.test(name)) return `arg`;
  return name;
}

/**
 * Resolve a class/protocol name to its on-disk filename stem.
 * For case-colliding classes, this returns the canonical name (the file that
 * contains all colliding classes). For everything else, returns the name itself.
 */
function resolveFileName(name: string, classToFile?: Map<string, string>): string {
  return classToFile?.get(name) ?? name;
}

/**
 * Emit import statements for a set of referenced classes/protocols, grouped by framework.
 */
function emitImports(
  refs: Set<string>,
  currentFramework: FrameworkConfig,
  allFrameworks: FrameworkConfig[],
  classToFile?: Map<string, string>
): string[] {
  const lines: string[] = [];

  // Group refs by framework
  const importsByFramework = new Map<string, string[]>();
  for (const refClass of refs) {
    const fw = getEntityFramework(refClass, allFrameworks);
    if (!fw) continue;
    if (!importsByFramework.has(fw)) {
      importsByFramework.set(fw, []);
    }
    importsByFramework.get(fw)!.push(refClass);
  }

  // When multiple classes are imported from the same file (because they were merged
  // due to case collisions), combine them into a single import statement.
  for (const [fwName, classes] of importsByFramework) {
    classes.sort();

    // Group classes by their resolved filename
    const byFile = new Map<string, string[]>();
    for (const refClass of classes) {
      const fileName = resolveFileName(refClass, classToFile);
      if (!byFile.has(fileName)) {
        byFile.set(fileName, []);
      }
      byFile.get(fileName)!.push(refClass);
    }

    for (const [fileName, names] of byFile) {
      const specifiers = names.map((n) => `_${n}`).join(", ");
      if (fwName === currentFramework.name) {
        lines.push(
          `import type { ${specifiers} } from "./${fileName}.js";`
        );
      } else {
        lines.push(
          `import type { ${specifiers} } from "../${fwName}/${fileName}.js";`
        );
      }
    }
  }

  return lines;
}

/**
 * Generate a .ts file for a single ObjC class.
 */
export function emitClassFile(
  cls: ObjCClass,
  currentFramework: FrameworkConfig,
  allFrameworks: FrameworkConfig[],
  allKnownClasses: Set<string>,
  allParsedClasses?: Map<string, ObjCClass>,
  allKnownProtocols?: Set<string>,
  classToFile?: Map<string, string>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import type { NobjcObject } from "objc-js";`);

  // Collect referenced classes for imports
  const refs = collectReferencedClasses(cls, allKnownClasses, allKnownProtocols);
  lines.push(...emitImports(refs, currentFramework, allFrameworks, classToFile));

  // Collect and emit struct type imports
  const structRefs = collectReferencedStructs(cls);
  if (structRefs.size > 0) {
    const sorted = [...structRefs].sort();
    lines.push(
      `import type { ${sorted.join(", ")} } from "../structs.js";`
    );
  }

  lines.push("");
  lines.push(...emitClassBody(cls, allKnownClasses, allParsedClasses));
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate a single .ts file containing multiple classes that share the same
 * filename on a case-insensitive filesystem (e.g., MTROTAFoo and MTROtaFoo).
 *
 * Classes are topologically sorted so that superclasses within the group
 * appear before their subclasses. All sibling classes are excluded from
 * imports since they coexist in the same file.
 */
export function emitMergedClassFile(
  classes: ObjCClass[],
  currentFramework: FrameworkConfig,
  allFrameworks: FrameworkConfig[],
  allKnownClasses: Set<string>,
  allParsedClasses?: Map<string, ObjCClass>,
  allKnownProtocols?: Set<string>,
  classToFile?: Map<string, string>
): string {
  // Set of class names in this merged file — these are "siblings"
  const siblingNames = new Set(classes.map((c) => c.name));

  // Topological sort: superclasses in the group come first.
  // Build adjacency: if cls.superclass is a sibling, cls depends on it.
  const sorted: ObjCClass[] = [];
  const visited = new Set<string>();

  function visit(cls: ObjCClass): void {
    if (visited.has(cls.name)) return;
    visited.add(cls.name);
    // If superclass is a sibling, visit it first
    if (cls.superclass && siblingNames.has(cls.superclass)) {
      const parent = classes.find((c) => c.name === cls.superclass);
      if (parent) visit(parent);
    }
    sorted.push(cls);
  }

  for (const cls of classes) {
    visit(cls);
  }

  // Collect all referenced classes/structs across all siblings
  const allRefs = new Set<string>();
  const allStructRefs = new Set<string>();

  for (const cls of sorted) {
    const refs = collectReferencedClasses(cls, allKnownClasses, allKnownProtocols);
    for (const ref of refs) {
      // Exclude siblings — they're defined in this same file
      if (!siblingNames.has(ref)) {
        allRefs.add(ref);
      }
    }
    const structs = collectReferencedStructs(cls);
    for (const s of structs) {
      allStructRefs.add(s);
    }
  }

  // Build the file
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import type { NobjcObject } from "objc-js";`);

  // Emit imports using shared helper (resolves case-collision filenames)
  lines.push(...emitImports(allRefs, currentFramework, allFrameworks, classToFile));

  // Emit struct imports
  if (allStructRefs.size > 0) {
    const sortedStructs = [...allStructRefs].sort();
    lines.push(
      `import type { ${sortedStructs.join(", ")} } from "../structs.js";`
    );
  }

  // Emit each class declaration
  for (const cls of sorted) {
    lines.push("");
    lines.push(...emitClassBody(
      cls,
      allKnownClasses,
      allParsedClasses,
    ));
  }

  lines.push("");
  return lines.join("\n");
}

/**
 * Emit the class declaration body (extends clause, methods, properties)
 * without the file-level header/imports. Used by both emitClassFile and
 * emitMergedClassFile.
 */
function emitClassBody(
  cls: ObjCClass,
  allKnownClasses: Set<string>,
  allParsedClasses?: Map<string, ObjCClass>,
): string[] {
  const lines: string[] = [];

  // Determine superclass type
  let superType: string;
  if (cls.superclass && allKnownClasses.has(cls.superclass)) {
    superType = `_${cls.superclass}`;
  } else {
    superType = "NobjcObject";
  }

  lines.push(`export declare class _${cls.name} extends ${superType} {`);

  // Emit instancetype overrides for alloc/new/init on subclasses.
  const selfType = `_${cls.name}`;
  const ownClassSelectors = new Set(cls.classMethods.map((m) => m.selector));
  const ownInstanceSelectors = new Set(cls.instanceMethods.map((m) => m.selector));

  if (cls.superclass) {
    const instancetypeOverrides: string[] = [];

    if (!ownClassSelectors.has("alloc")) {
      instancetypeOverrides.push(`  static alloc(): ${selfType};`);
    }
    if (!ownClassSelectors.has("new")) {
      instancetypeOverrides.push(`  static new(): ${selfType};`);
    }
    if (!ownInstanceSelectors.has("init")) {
      instancetypeOverrides.push(`  init(): ${selfType};`);
    }

    for (const line of instancetypeOverrides) {
      lines.push(line);
    }
  }

  // Build parent signature map for override conflict detection
  interface ParentSig {
    returnType: string;
    paramTypes: string[];
  }
  const parentSignatures = new Map<string, ParentSig>();
  if (allParsedClasses && cls.superclass) {
    let current = cls.superclass;
    while (current) {
      const parentCls = allParsedClasses.get(current);
      if (!parentCls) break;
      for (const prop of parentCls.properties) {
        const tsType = mapReturnType(prop.type, parentCls.name);
        if (!parentSignatures.has(prop.name)) {
          parentSignatures.set(prop.name, { returnType: tsType, paramTypes: [] });
        }
        if (!prop.readonly) {
          const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
          if (!parentSignatures.has(setterName)) {
            const paramType = mapParamType(prop.type, parentCls.name);
            parentSignatures.set(setterName, { returnType: "void", paramTypes: [paramType] });
          }
        }
      }
      for (const method of [...parentCls.instanceMethods, ...parentCls.classMethods]) {
        const jsName = selectorToJS(method.selector);
        if (!parentSignatures.has(jsName)) {
          const retType = mapReturnType(method.returnType, parentCls.name);
          const paramTypes = method.parameters.map((p) => mapParamType(p.type, parentCls.name));
          parentSignatures.set(jsName, { returnType: retType, paramTypes });
        }
      }
      current = parentCls.superclass ?? "";
    }
  }

  function shouldSkipOverride(jsName: string, tsReturnType: string, childParamTypes?: string[]): boolean {
    const parentSig = parentSignatures.get(jsName);
    if (!parentSig) return false;

    if (tsReturnType === "NobjcObject" && parentSig.returnType !== "NobjcObject") {
      return true;
    }
    if (tsReturnType.includes(" | null") && !parentSig.returnType.includes(" | null")) {
      return true;
    }
    if (childParamTypes && parentSig.paramTypes.length === childParamTypes.length) {
      for (let i = 0; i < childParamTypes.length; i++) {
        const childParam = childParamTypes[i]!;
        const parentParam = parentSig.paramTypes[i]!;
        if (childParam === parentParam) continue;
        return true;
      }
    }
    return false;
  }

  // Split properties into class and instance
  const classProps = cls.properties.filter((p) => p.isClassProperty);
  const instanceProps = cls.properties.filter((p) => !p.isClassProperty);

  // Emit class methods (static), excluding class property accessors
  const classPropertyNames = new Set(classProps.map((p) => p.name));
  const classMethods = cls.classMethods.filter(
    (m) => !classPropertyNames.has(m.selector)
  );

  const hasClassSection = classMethods.length > 0 || classProps.length > 0;
  if (hasClassSection) {
    lines.push("  // Class methods");
    for (const method of classMethods) {
      const jsName = selectorToJS(method.selector);
      const retType = mapReturnType(method.returnType, cls.name);
      const paramTypes = method.parameters.map((p) => mapParamType(p.type, cls.name));
      if (shouldSkipOverride(jsName, retType, paramTypes)) continue;
      const sig = emitMethodSignature(method, cls.name);
      if (sig) lines.push(sig);
    }
    for (const prop of classProps) {
      const tsType = mapReturnType(prop.type, cls.name);
      if (shouldSkipOverride(prop.name, tsType, [])) continue;
      const jsdoc = buildJSDoc({
        description: prop.description,
        isDeprecated: prop.isDeprecated,
        deprecationMessage: prop.deprecationMessage,
      });
      lines.push(...jsdoc);
      lines.push(`  static ${prop.name}(): ${tsType};`);
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, cls.name);
        if (!shouldSkipOverride(setterName, "void", [paramType])) {
          lines.push(`  static ${setterName}(value: ${paramType}): void;`);
        }
      }
    }
  }

  // Emit instance methods
  const instancePropertyNames = new Set(instanceProps.map((p) => p.name));
  const regularMethods = cls.instanceMethods.filter(
    (m) => !instancePropertyNames.has(m.selector)
  );

  if (regularMethods.length > 0) {
    if (hasClassSection) lines.push("");
    lines.push("  // Instance methods");
    for (const method of regularMethods) {
      const jsName = selectorToJS(method.selector);
      const retType = mapReturnType(method.returnType, cls.name);
      const paramTypes = method.parameters.map((p) => mapParamType(p.type, cls.name));
      if (shouldSkipOverride(jsName, retType, paramTypes)) continue;
      const sig = emitMethodSignature(method, cls.name);
      if (sig) lines.push(sig);
    }
  }

  // Emit instance properties
  if (instanceProps.length > 0) {
    if (regularMethods.length > 0 || hasClassSection) lines.push("");
    lines.push("  // Properties");
    for (const prop of instanceProps) {
      const tsType = mapReturnType(prop.type, cls.name);
      if (shouldSkipOverride(prop.name, tsType, [])) continue;
      const jsdoc = buildJSDoc({
        description: prop.description,
        isDeprecated: prop.isDeprecated,
        deprecationMessage: prop.deprecationMessage,
      });
      lines.push(...jsdoc);
      lines.push(`  ${prop.name}(): ${tsType};`);
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, cls.name);
        if (!shouldSkipOverride(setterName, "void", [paramType])) {
          lines.push(`  ${setterName}(value: ${paramType}): void;`);
        }
      }
    }
  }

  lines.push("}");

  return lines;
}

/**
 * Given an ObjCProtocol, determine which struct type names it references.
 */
function collectProtocolReferencedStructs(proto: ObjCProtocol): Set<string> {
  const refs = new Set<string>();

  function extractStructRefs(typeStr: string): void {
    for (const structName of STRUCT_TS_TYPES) {
      if (typeStr === structName || typeStr.startsWith(structName + " ")) {
        refs.add(structName);
      }
    }
  }

  const allMethods = [...proto.instanceMethods, ...proto.classMethods];
  for (const method of allMethods) {
    extractStructRefs(mapReturnType(method.returnType, proto.name));
    for (const param of method.parameters) {
      extractStructRefs(mapParamType(param.type, proto.name));
    }
  }
  for (const prop of proto.properties) {
    extractStructRefs(mapReturnType(prop.type, proto.name));
    extractStructRefs(mapParamType(prop.type, proto.name));
  }

  return refs;
}

/**
 * Given an ObjCProtocol, determine which other class/protocol names it references.
 */
function collectProtocolReferencedClasses(
  proto: ObjCProtocol,
  allKnownClasses: Set<string>,
  allKnownProtocols?: Set<string>
): Set<string> {
  const refs = new Set<string>();

  function extractClassRefs(typeStr: string): void {
    const regex = /_(\w+)/g;
    let match;
    while ((match = regex.exec(typeStr)) !== null) {
      const name = match[1]!;
      if (allKnownClasses.has(name) || allKnownProtocols?.has(name)) {
        refs.add(name);
      }
    }
  }

  const allMethods = [...proto.instanceMethods, ...proto.classMethods];
  for (const method of allMethods) {
    const retType = mapReturnType(method.returnType, proto.name);
    extractClassRefs(retType);
    for (const param of method.parameters) {
      const pType = mapParamType(param.type, proto.name);
      extractClassRefs(pType);
    }
  }

  for (const prop of proto.properties) {
    const pType = mapReturnType(prop.type, proto.name);
    extractClassRefs(pType);
  }

  return refs;
}

/**
 * Generate a .ts file for a single ObjC protocol.
 * Protocols are emitted as TypeScript interfaces with optional methods,
 * representing the method map shape for NobjcProtocol.implement().
 */
export function emitProtocolFile(
  proto: ObjCProtocol,
  currentFramework: FrameworkConfig,
  allFrameworks: FrameworkConfig[],
  allKnownClasses: Set<string>,
  allKnownProtocols: Set<string>,
  classToFile?: Map<string, string>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import type { NobjcObject } from "objc-js";`);

  // Collect referenced classes for imports
  const refs = collectProtocolReferencedClasses(proto, allKnownClasses, allKnownProtocols);

  // Add extended protocols to the refs set so they go through emitImports too
  // (protocols are entities just like classes in terms of import resolution)
  for (const extProto of proto.extendedProtocols) {
    if (allKnownProtocols.has(extProto)) {
      refs.add(extProto);
    }
  }

  lines.push(...emitImports(refs, currentFramework, allFrameworks, classToFile));

  // Collect and emit struct type imports
  const structRefs = collectProtocolReferencedStructs(proto);
  if (structRefs.size > 0) {
    const sorted = [...structRefs].sort();
    lines.push(
      `import type { ${sorted.join(", ")} } from "../structs.js";`
    );
  }

  lines.push("");

  // Build extends clause from extended protocols we have types for
  const extendsClauses: string[] = [];
  for (const extProto of proto.extendedProtocols) {
    if (allKnownProtocols.has(extProto)) {
      extendsClauses.push(`_${extProto}`);
    }
  }
  const extendsStr = extendsClauses.length > 0
    ? ` extends ${extendsClauses.join(", ")}`
    : "";

  lines.push(`export interface _${proto.name}${extendsStr} {`);

  // Split properties into class and instance
  const instanceProps = proto.properties.filter((p) => !p.isClassProperty);

  // Emit instance methods (all optional with ? syntax)
  const instancePropertyNames = new Set(instanceProps.map((p) => p.name));
  const regularMethods = proto.instanceMethods.filter(
    (m) => !instancePropertyNames.has(m.selector)
  );

  if (regularMethods.length > 0) {
    lines.push("  // Instance methods");
    for (const method of regularMethods) {
      const jsName = selectorToJS(method.selector);
      const returnType = mapReturnType(method.returnType, proto.name);
      const params: string[] = [];
      for (const param of method.parameters) {
        const tsType = mapParamType(param.type, proto.name);
        const safeName = sanitizeParamName(param.name);
        params.push(`${safeName}: ${tsType}`);
      }
      const jsdoc = buildJSDoc({
        description: method.description,
        isDeprecated: method.isDeprecated,
        deprecationMessage: method.deprecationMessage,
      });
      if (jsdoc.length > 0) lines.push(...jsdoc);
      lines.push(`  ${jsName}?(${params.join(", ")}): ${returnType};`);
    }
  }

  // Emit instance properties (as optional getter methods)
  if (instanceProps.length > 0) {
    if (regularMethods.length > 0) lines.push("");
    lines.push("  // Properties");
    for (const prop of instanceProps) {
      const tsType = mapReturnType(prop.type, proto.name);
      const jsdoc = buildJSDoc({
        description: prop.description,
        isDeprecated: prop.isDeprecated,
        deprecationMessage: prop.deprecationMessage,
      });
      if (jsdoc.length > 0) lines.push(...jsdoc);
      lines.push(`  ${prop.name}?(): ${tsType};`);
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, proto.name);
        lines.push(`  ${setterName}?(value: ${paramType}): void;`);
      }
    }
  }

  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

/**
 * Determine which framework a protocol belongs to.
 */
function getProtocolFramework(
  protocolName: string,
  frameworks: FrameworkConfig[]
): string | null {
  for (const fw of frameworks) {
    if (fw.protocols?.includes(protocolName)) {
      return fw.name;
    }
  }
  return null;
}

// --- Struct definitions for code generation ---
// Each struct defines its TypeScript interface and factory function.
// Field info comes from the objc-js native bridge's KNOWN_STRUCT_FIELDS table
// (see struct-utils.h). Structs not in that table get positional names (field0, field1, ...).

interface StructFieldDef {
  name: string;
  type: string; // TypeScript type: "number" or a struct interface name
}

type StructDef = {
  /** The TypeScript interface/function name (e.g., "CGPoint") */
  tsName: string;
  /** Fields with their names and types */
  fields: StructFieldDef[];
  /** Factory function parameter list — for nested structs, these are flat params */
  factoryParams?: { name: string; type: string }[];
  /** Factory function body expression */
  factoryBody?: string;
} | {
  /** The TypeScript alias name (e.g., "NSPoint") */
  tsName: string;
  /** If this is an alias for another struct (e.g., NSPoint = CGPoint) */
  aliasOf: string;
};

/**
 * All struct definitions for src/structs.ts generation.
 * Order matters — dependencies must come before dependents.
 */
const STRUCT_DEFS: StructDef[] = [
  // --- Core Geometry ---
  {
    tsName: "CGPoint",
    fields: [
      { name: "x", type: "number" },
      { name: "y", type: "number" },
    ],
  },
  {
    tsName: "CGSize",
    fields: [
      { name: "width", type: "number" },
      { name: "height", type: "number" },
    ],
  },
  {
    tsName: "CGRect",
    fields: [
      { name: "origin", type: "CGPoint" },
      { name: "size", type: "CGSize" },
    ],
    factoryParams: [
      { name: "x", type: "number" },
      { name: "y", type: "number" },
      { name: "width", type: "number" },
      { name: "height", type: "number" },
    ],
    factoryBody: `{ origin: { x, y }, size: { width, height } }`,
  },
  {
    tsName: "CGVector",
    fields: [
      { name: "dx", type: "number" },
      { name: "dy", type: "number" },
    ],
  },
  // --- NS Aliases ---
  { tsName: "NSPoint", aliasOf: "CGPoint" },
  { tsName: "NSSize", aliasOf: "CGSize" },
  { tsName: "NSRect", aliasOf: "CGRect" },
  // --- Foundation Structs ---
  {
    tsName: "NSRange",
    fields: [
      { name: "location", type: "number" },
      { name: "length", type: "number" },
    ],
  },
  {
    tsName: "NSEdgeInsets",
    fields: [
      { name: "top", type: "number" },
      { name: "left", type: "number" },
      { name: "bottom", type: "number" },
      { name: "right", type: "number" },
    ],
  },
  {
    tsName: "NSDirectionalEdgeInsets",
    fields: [
      { name: "top", type: "number" },
      { name: "leading", type: "number" },
      { name: "bottom", type: "number" },
      { name: "trailing", type: "number" },
    ],
  },
  // --- Transforms ---
  {
    tsName: "CGAffineTransform",
    fields: [
      { name: "a", type: "number" },
      { name: "b", type: "number" },
      { name: "c", type: "number" },
      { name: "d", type: "number" },
      { name: "tx", type: "number" },
      { name: "ty", type: "number" },
    ],
  },
  // NSAffineTransformStruct is not in the objc-js known field table,
  // so the runtime uses positional names (field0, field1, ...).
  // The actual ObjC fields are: m11, m12, m21, m22, tX, tY.
  {
    tsName: "NSAffineTransformStruct",
    fields: [
      { name: "field0", type: "number" },
      { name: "field1", type: "number" },
      { name: "field2", type: "number" },
      { name: "field3", type: "number" },
      { name: "field4", type: "number" },
      { name: "field5", type: "number" },
    ],
  },
  // --- Structs not in objc-js known field table (positional names) ---
  // NSDecimal: ObjC struct with _exponent, _length, _isNegative, _isCompact, _reserved, _mantissa[8]
  // The runtime has no named fields for this, so it uses positional names.
  // However, it's a packed struct with bitfields — at the JS level it surfaces as positional fields.
  {
    tsName: "NSDecimal",
    fields: [
      { name: "field0", type: "number" },
      { name: "field1", type: "number" },
      { name: "field2", type: "number" },
      { name: "field3", type: "number" },
      { name: "field4", type: "number" },
      { name: "field5", type: "number" },
      { name: "field6", type: "number" },
      { name: "field7", type: "number" },
    ],
  },
  {
    tsName: "NSOperatingSystemVersion",
    fields: [
      { name: "field0", type: "number" },
      { name: "field1", type: "number" },
      { name: "field2", type: "number" },
    ],
  },
];

/**
 * Generate the src/structs.ts file with all struct interface + factory function definitions.
 */
export function emitStructsFile(): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`// Struct type definitions and factory functions for objc-js.`);
  lines.push(`// These match the field names produced by the objc-js native bridge.`);

  let lastSection = "";

  for (const def of STRUCT_DEFS) {
    const isAlias = "aliasOf" in def;

    // Determine section for comment headers
    const section = isAlias ? "alias"
      : def.tsName === "CGAffineTransform" || def.tsName === "NSAffineTransformStruct" ? "Transforms"
      : def.tsName.startsWith("CG") ? "CoreGraphics"
      : def.tsName === "NSRange" || def.tsName === "NSEdgeInsets" || def.tsName === "NSDirectionalEdgeInsets" ? "Foundation"
      : "Other";

    // Emit section headers
    if (section !== lastSection && !isAlias) {
      lines.push("");
      if (section === "CoreGraphics") lines.push("// --- Core Geometry ---");
      else if (section === "Foundation") lines.push("// --- Foundation Structs ---");
      else if (section === "Transforms") lines.push("// --- Transforms ---");
      else if (section === "Other") lines.push("// --- Other Structs (positional field names) ---");
      lastSection = section;
    }

    if (isAlias) {
      // Alias: emit type + const
      if (def.tsName === "NSPoint") {
        // Start NS aliases section
        lines.push("");
        lines.push("// --- NS Aliases (identical layout to CG counterparts) ---");
      }
      lines.push("");
      lines.push(`export type ${def.tsName} = ${def.aliasOf};`);
      lines.push(`export const ${def.tsName} = ${def.aliasOf};`);
      continue;
    }

    // Interface
    lines.push("");
    lines.push(`export interface ${def.tsName} {`);
    for (const field of def.fields) {
      lines.push(`  ${field.name}: ${field.type};`);
    }
    lines.push(`}`);

    // Factory function
    const params = def.factoryParams ?? def.fields.map((f) => ({ name: f.name, type: f.type }));
    const paramStr = params.map((p) => `${p.name}: ${p.type}`).join(", ");

    // For struct fields that reference other struct types, the factory needs
    // special handling. If factoryBody is provided, use it; otherwise generate
    // a simple object literal from the fields.
    const body = def.factoryBody ?? `{ ${def.fields.map((f) => f.name).join(", ")} }`;

    lines.push("");
    lines.push(`export function ${def.tsName}(${paramStr}): ${def.tsName} {`);
    lines.push(`  return ${body};`);
    lines.push(`}`);
  }

  lines.push("");

  return lines.join("\n");
}

/**
 * Generate the barrel index.ts for a framework.
 *
 * @param caseCollisions - Map from canonical filename to all class names in
 *   that file. Colliding classes import from the canonical file rather than
 *   their own name. Pass an empty map when there are no collisions.
 */
export function emitFrameworkIndex(
  framework: FrameworkConfig,
  generatedClasses: string[],
  generatedProtocols?: string[],
  caseCollisions?: Map<string, string[]>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import { NobjcLibrary } from "objc-js";`);
  lines.push("");
  lines.push(
    `const ${framework.name} = new NobjcLibrary("${framework.libraryPath}");`
  );
  lines.push("");

  // Build a reverse lookup: className → canonical filename for collision groups
  const classToFile = new Map<string, string>();
  if (caseCollisions) {
    for (const [canonical, group] of caseCollisions) {
      for (const name of group) {
        classToFile.set(name, canonical);
      }
    }
  }

  for (const className of generatedClasses) {
    const fileName = classToFile.get(className) ?? className;
    lines.push(
      `import type { _${className} } from "./${fileName}.js";`
    );
    lines.push(
      `export const ${className} = ${framework.name}["${className}"] as unknown as typeof _${className};`
    );
    lines.push(`export type { _${className} };`);
    lines.push("");
  }

  // Export protocol types (type-only, no runtime value)
  if (generatedProtocols && generatedProtocols.length > 0) {
    for (const protoName of generatedProtocols) {
      lines.push(
        `import type { _${protoName} } from "./${protoName}.js";`
      );
      lines.push(`export type { _${protoName} };`);
      lines.push("");
    }
  }

  return lines.join("\n");
}

/**
 * Generate the top-level src/index.ts barrel.
 * Only exports structs and delegates — frameworks are imported via
 * subpath exports (e.g., "objcjs-types/AppKit") to avoid loading
 * all framework types into the editor at once.
 */
export function emitTopLevelIndex(frameworkNames: string[]): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push("");

  lines.push(`export * from "./structs.js";`);
  lines.push(`export { createDelegate } from "./delegates.js";`);
  lines.push(`export type { ProtocolMap } from "./delegates.js";`);
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate src/delegates.ts — a ProtocolMap interface mapping ObjC protocol
 * name strings to their TypeScript interface types, plus a type-safe
 * createDelegate() wrapper around NobjcProtocol.implement().
 */
export function emitDelegatesFile(
  frameworks: FrameworkConfig[],
  generatedProtocolsByFramework: Map<string, string[]>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import { NobjcProtocol } from "objc-js";`);
  lines.push(`import type { NobjcObject } from "objc-js";`);
  lines.push("");

  // Collect all generated protocols with their framework for imports
  const allProtocols: { name: string; framework: string }[] = [];
  for (const fw of frameworks) {
    const generated = generatedProtocolsByFramework.get(fw.name) ?? [];
    for (const name of generated) {
      allProtocols.push({ name, framework: fw.name });
    }
  }

  // Sort for deterministic output
  allProtocols.sort((a, b) => a.name.localeCompare(b.name));

  // Emit imports
  for (const proto of allProtocols) {
    lines.push(
      `import type { _${proto.name} } from "./${proto.framework}/${proto.name}.js";`
    );
  }
  lines.push("");

  // Emit ProtocolMap interface
  lines.push(`/** Maps ObjC protocol name strings to their TypeScript interface types. */`);
  lines.push(`export interface ProtocolMap {`);
  for (const proto of allProtocols) {
    lines.push(`  ${proto.name}: _${proto.name};`);
  }
  lines.push(`}`);
  lines.push("");

  // Emit createDelegate function
  lines.push(`/**`);
  lines.push(` * Create a type-safe Objective-C delegate object.`);
  lines.push(` *`);
  lines.push(` * Wraps NobjcProtocol.implement() with full type inference —`);
  lines.push(` * method names, parameter types, and return types are all inferred`);
  lines.push(` * from the protocol name string.`);
  lines.push(` *`);
  lines.push(` * @example`);
  lines.push(` * const delegate = createDelegate("NSWindowDelegate", {`);
  lines.push(` *   windowDidResize$(notification) {`);
  lines.push(` *     console.log("Window resized!");`);
  lines.push(` *   },`);
  lines.push(` * });`);
  lines.push(` */`);
  lines.push(`export function createDelegate<K extends keyof ProtocolMap>(`);
  lines.push(`  protocolName: K,`);
  lines.push(`  methods: Partial<ProtocolMap[K]>,`);
  lines.push(`): NobjcObject {`);
  lines.push(`  return NobjcProtocol.implement(`);
  lines.push(`    protocolName,`);
  lines.push(`    methods as Record<string, (...args: any[]) => any>,`);
  lines.push(`  );`);
  lines.push(`}`);
  lines.push("");

  return lines.join("\n");
}
