/**
 * Custom header generator CLI — generates TypeScript type declarations
 * from arbitrary Objective-C header files (not just SDK frameworks).
 *
 * Usage:
 *   bun run generate:custom header1.h [header2.h ...] [--include <header>] [-I <path>] [-D <macro[=value]>]
 *
 * Output goes to ./objcjs-types-output/ in the current working directory.
 *
 * Generated files import SDK types from the "objcjs-types" package
 * (e.g., `import type { _NSObject } from "objcjs-types/Foundation"`)
 * and custom types use relative imports within the output directory.
 */

import { mkdir, writeFile, rm } from "fs/promises";
import { existsSync } from "fs";
import { join, resolve, basename } from "path";
import { discoverAllFrameworks, type FrameworkConfig } from "./frameworks.ts";
import { discoverFramework } from "./discover.ts";
import { clangBatchASTDump, type ClangASTNode } from "./clang.ts";
import {
  propagateLocFile,
  parseAST,
  parseProtocols,
  parseIntegerEnums,
  parseStringEnums,
  parseStructs,
  parseTypedefs
} from "./ast-parser.ts";
import type { ObjCClass, ObjCProtocol, ObjCIntegerEnum, ObjCStringEnum } from "./ast-parser.ts";
import {
  setKnownClasses,
  setKnownProtocols,
  setProtocolConformers,
  setKnownIntegerEnums,
  setKnownStringEnums,
  setKnownStructs,
  setKnownTypedefs,
  mapReturnType,
  mapParamType,
  selectorToJS,
  STRUCT_TS_TYPES
} from "./type-mapper.ts";
import { emitClassBody, sanitizeParamName, emitIntegerEnumFile, emitStringEnumFile } from "./emitter.ts";

const AUTOGEN_HEADER = `// AUTO-GENERATED by objcjs-types custom generator — DO NOT EDIT`;
const OUTPUT_DIR = join(process.cwd(), "objcjs-types-output");

// ============================================================================
// CLI argument parsing
// ============================================================================

interface CLIArgs {
  headerPaths: string[];
  includes: string[];
  includeDirs: string[];
  defines: string[];
}

function parseArgs(): CLIArgs {
  const args = process.argv.slice(2);
  const headerPaths: string[] = [];
  const includes: string[] = [];
  const includeDirs: string[] = [];
  const defines: string[] = [];

  for (let i = 0; i < args.length; i++) {
    const arg = args[i]!;
    if (arg === "--include" && i + 1 < args.length) {
      includes.push(args[++i]!);
    } else if (arg === "-I" && i + 1 < args.length) {
      includeDirs.push(args[++i]!);
    } else if (arg.startsWith("-I")) {
      // Support -I/path/to/dir (no space)
      includeDirs.push(arg.slice(2));
    } else if (arg === "-D" && i + 1 < args.length) {
      defines.push(args[++i]!);
    } else if (arg.startsWith("-D")) {
      // Support -DMACRO=value (no space)
      defines.push(arg.slice(2));
    } else if (arg.startsWith("-")) {
      console.error(`Unknown flag: ${arg}`);
      console.error(
        "Usage: bun run generate:custom header1.h [header2.h ...] [--include <header>] [-I <path>] [-D <macro[=value]>]"
      );
      process.exit(1);
    } else {
      headerPaths.push(resolve(arg));
    }
  }

  if (headerPaths.length === 0) {
    console.error("Error: No header files specified.");
    console.error(
      "Usage: bun run generate:custom header1.h [header2.h ...] [--include <header>] [-I <path>] [-D <macro[=value]>]"
    );
    process.exit(1);
  }

  // Validate that all headers exist
  for (const h of headerPaths) {
    if (!existsSync(h)) {
      console.error(`Error: Header file not found: ${h}`);
      process.exit(1);
    }
  }

  return { headerPaths, includes, includeDirs, defines };
}

// ============================================================================
// Discovery helpers — scan custom headers for class/protocol/enum names
// ============================================================================

/** Matches `@interface ClassName` (not categories) */
const INTERFACE_RE = /@interface\s+(\w+)/;
const CATEGORY_RE = /@interface\s+\w+(?:<[^>]*>)?\s*\(/;
const PROTOCOL_RE = /@protocol\s+(\w+)/;
const NS_ENUM_RE = /typedef\s+NS_(?:ENUM|OPTIONS)\s*\(\s*\w+\s*,\s*(\w+)\s*\)/;
const NS_STRING_ENUM_RE = /typedef\s+NSString\s*\*\s*(\w+)\s+NS_(?:TYPED_EXTENSIBLE_ENUM|STRING_ENUM|TYPED_ENUM)/;

interface CustomDiscovery {
  classes: Set<string>;
  protocols: Set<string>;
  integerEnums: Set<string>;
  stringEnums: Set<string>;
}

/** Scan custom header files for class/protocol/enum declarations. */
async function discoverCustomHeaders(headerPaths: string[]): Promise<CustomDiscovery> {
  const classes = new Set<string>();
  const protocols = new Set<string>();
  const integerEnums = new Set<string>();
  const stringEnums = new Set<string>();

  for (const headerPath of headerPaths) {
    const content = await Bun.file(headerPath).text();
    const lines = content.split("\n");

    for (const line of lines) {
      const ifaceMatch = INTERFACE_RE.exec(line);
      if (ifaceMatch && !CATEGORY_RE.test(line)) {
        classes.add(ifaceMatch[1]!);
      }

      const protoMatch = PROTOCOL_RE.exec(line);
      if (protoMatch && !line.includes(";")) {
        protocols.add(protoMatch[1]!);
      }

      const enumMatch = NS_ENUM_RE.exec(line);
      if (enumMatch) {
        integerEnums.add(enumMatch[1]!);
      }

      const stringEnumMatch = NS_STRING_ENUM_RE.exec(line);
      if (stringEnumMatch) {
        stringEnums.add(stringEnumMatch[1]!);
      }
    }
  }

  return { classes, protocols, integerEnums, stringEnums };
}

// ============================================================================
// Custom emit functions — generate .ts files with custom import resolution
// ============================================================================

/**
 * Resolve a type reference to its import source.
 * SDK types import from "objcjs-types/<Framework>", custom types use relative "./<Name>.js".
 */
function resolveImportPath(
  name: string,
  sdkClassFrameworkMap: Map<string, string>,
  sdkProtocolFrameworkMap: Map<string, string>,
  sdkEnumFrameworkMap: Map<string, string>,
  customNames: Set<string>
): { path: string; isCustom: boolean } | null {
  if (customNames.has(name)) {
    return { path: `./${name}.js`, isCustom: true };
  }
  const classFw = sdkClassFrameworkMap.get(name);
  if (classFw) {
    return { path: `objcjs-types/${classFw}`, isCustom: false };
  }
  const protoFw = sdkProtocolFrameworkMap.get(name);
  if (protoFw) {
    return { path: `objcjs-types/${protoFw}`, isCustom: false };
  }
  const enumFw = sdkEnumFrameworkMap.get(name);
  if (enumFw) {
    return { path: `objcjs-types/${enumFw}`, isCustom: false };
  }
  return null;
}

/**
 * Extract all _ClassName references from a mapped type string.
 */
function extractClassRefs(typeStr: string, selfName: string, allKnown: Set<string>): Set<string> {
  const refs = new Set<string>();
  const regex = /_(\w+)/g;
  let match;
  while ((match = regex.exec(typeStr)) !== null) {
    const name = match[1]!;
    if (name === selfName) continue;
    if (allKnown.has(name)) {
      refs.add(name);
    }
  }
  return refs;
}

/**
 * Collect all class/protocol names referenced by a class's methods and properties.
 */
function collectClassRefs(cls: ObjCClass, allKnownClasses: Set<string>, allKnownProtocols: Set<string>): Set<string> {
  const allKnown = new Set([...allKnownClasses, ...allKnownProtocols]);
  const refs = new Set<string>();

  // Superclass
  if (cls.superclass && allKnown.has(cls.superclass)) {
    refs.add(cls.superclass);
  }

  // Conformed protocols
  for (const protoName of cls.protocols) {
    if (allKnownProtocols.has(protoName)) {
      refs.add(protoName);
    }
  }

  // Method signatures
  const allMethods = [...cls.instanceMethods, ...cls.classMethods];
  for (const method of allMethods) {
    for (const ref of extractClassRefs(mapReturnType(method.returnType, cls.name), cls.name, allKnown)) {
      refs.add(ref);
    }
    for (const param of method.parameters) {
      for (const ref of extractClassRefs(mapParamType(param.type, cls.name), cls.name, allKnown)) {
        refs.add(ref);
      }
    }
  }

  // Properties
  for (const prop of cls.properties) {
    for (const ref of extractClassRefs(mapReturnType(prop.type, cls.name), cls.name, allKnown)) {
      refs.add(ref);
    }
    for (const ref of extractClassRefs(mapParamType(prop.type, cls.name), cls.name, allKnown)) {
      refs.add(ref);
    }
  }

  refs.delete(cls.name);
  return refs;
}

/**
 * Collect all struct type names referenced by a class.
 */
function collectStructRefs(cls: ObjCClass): Set<string> {
  const refs = new Set<string>();
  function extract(typeStr: string): void {
    for (const structName of STRUCT_TS_TYPES) {
      if (typeStr === structName || typeStr.startsWith(structName + " ")) {
        refs.add(structName);
      }
    }
  }
  for (const method of [...cls.instanceMethods, ...cls.classMethods]) {
    extract(mapReturnType(method.returnType, cls.name));
    for (const param of method.parameters) {
      extract(mapParamType(param.type, cls.name));
    }
  }
  for (const prop of cls.properties) {
    extract(mapReturnType(prop.type, cls.name));
    extract(mapParamType(prop.type, cls.name));
  }
  return refs;
}

/**
 * Collect all enum type names referenced by a class.
 */
function collectEnumRefs(
  cls: ObjCClass,
  allKnownIntegerEnums: Set<string>,
  allKnownStringEnums: Set<string>
): Set<string> {
  const refs = new Set<string>();
  function extract(typeStr: string): void {
    for (const part of typeStr.split(" | ")) {
      const trimmed = part.trim();
      if (allKnownIntegerEnums.has(trimmed) || allKnownStringEnums.has(trimmed)) {
        refs.add(trimmed);
      }
    }
  }
  for (const method of [...cls.instanceMethods, ...cls.classMethods]) {
    extract(mapReturnType(method.returnType, cls.name));
    for (const param of method.parameters) {
      extract(mapParamType(param.type, cls.name));
    }
  }
  for (const prop of cls.properties) {
    extract(mapReturnType(prop.type, cls.name));
    extract(mapParamType(prop.type, cls.name));
  }
  return refs;
}

/**
 * Collect all class/protocol names referenced by a protocol's methods and properties.
 */
function collectProtocolClassRefs(
  proto: ObjCProtocol,
  allKnownClasses: Set<string>,
  allKnownProtocols: Set<string>
): Set<string> {
  const allKnown = new Set([...allKnownClasses, ...allKnownProtocols]);
  const refs = new Set<string>();

  // Extended protocols
  for (const ext of proto.extendedProtocols) {
    if (allKnown.has(ext)) {
      refs.add(ext);
    }
  }

  // Method signatures
  for (const method of [...proto.instanceMethods, ...proto.classMethods]) {
    for (const ref of extractClassRefs(mapReturnType(method.returnType, proto.name), proto.name, allKnown)) {
      refs.add(ref);
    }
    for (const param of method.parameters) {
      for (const ref of extractClassRefs(mapParamType(param.type, proto.name), proto.name, allKnown)) {
        refs.add(ref);
      }
    }
  }

  for (const prop of proto.properties) {
    for (const ref of extractClassRefs(mapReturnType(prop.type, proto.name), proto.name, allKnown)) {
      refs.add(ref);
    }
    for (const ref of extractClassRefs(mapParamType(prop.type, proto.name), proto.name, allKnown)) {
      refs.add(ref);
    }
  }

  refs.delete(proto.name);
  return refs;
}

/**
 * Collect struct refs from a protocol.
 */
function collectProtocolStructRefs(proto: ObjCProtocol): Set<string> {
  const refs = new Set<string>();
  function extract(typeStr: string): void {
    for (const structName of STRUCT_TS_TYPES) {
      if (typeStr === structName || typeStr.startsWith(structName + " ")) {
        refs.add(structName);
      }
    }
  }
  for (const method of [...proto.instanceMethods, ...proto.classMethods]) {
    extract(mapReturnType(method.returnType, proto.name));
    for (const param of method.parameters) {
      extract(mapParamType(param.type, proto.name));
    }
  }
  for (const prop of proto.properties) {
    extract(mapReturnType(prop.type, proto.name));
    extract(mapParamType(prop.type, proto.name));
  }
  return refs;
}

/**
 * Collect enum refs from a protocol.
 */
function collectProtocolEnumRefs(
  proto: ObjCProtocol,
  allKnownIntegerEnums: Set<string>,
  allKnownStringEnums: Set<string>
): Set<string> {
  const refs = new Set<string>();
  function extract(typeStr: string): void {
    for (const part of typeStr.split(" | ")) {
      const trimmed = part.trim();
      if (allKnownIntegerEnums.has(trimmed) || allKnownStringEnums.has(trimmed)) {
        refs.add(trimmed);
      }
    }
  }
  for (const method of [...proto.instanceMethods, ...proto.classMethods]) {
    extract(mapReturnType(method.returnType, proto.name));
    for (const param of method.parameters) {
      extract(mapParamType(param.type, proto.name));
    }
  }
  for (const prop of proto.properties) {
    extract(mapReturnType(prop.type, proto.name));
    extract(mapParamType(prop.type, proto.name));
  }
  return refs;
}

/**
 * Emit imports for a set of referenced names, routing to SDK packages or relative paths.
 */
function emitCustomImports(
  refs: Set<string>,
  sdkClassFrameworkMap: Map<string, string>,
  sdkProtocolFrameworkMap: Map<string, string>,
  sdkEnumFrameworkMap: Map<string, string>,
  customNames: Set<string>
): string[] {
  const lines: string[] = [];

  // Group by import path
  const byPath = new Map<string, string[]>();
  for (const name of [...refs].sort()) {
    const resolved = resolveImportPath(
      name,
      sdkClassFrameworkMap,
      sdkProtocolFrameworkMap,
      sdkEnumFrameworkMap,
      customNames
    );
    if (!resolved) continue;
    if (!byPath.has(resolved.path)) {
      byPath.set(resolved.path, []);
    }
    byPath.get(resolved.path)!.push(name);
  }

  for (const [path, names] of byPath) {
    const specifiers = names.map((n) => `_${n}`).join(", ");
    lines.push(`import type { ${specifiers} } from "${path}";`);
  }

  return lines;
}

/**
 * Emit struct imports, routing to SDK package or skipping (custom headers
 * generally don't define structs — they come from SDK pre-includes).
 */
function emitCustomStructImports(refs: Set<string>): string[] {
  const lines: string[] = [];
  for (const name of [...refs].sort()) {
    // Structs are exported from objcjs-types top-level
    lines.push(`import type { ${name} } from "objcjs-types";`);
  }
  return lines;
}

/**
 * Emit enum imports, routing to the correct SDK framework package.
 */
function emitCustomEnumImports(
  refs: Set<string>,
  sdkEnumFrameworkMap: Map<string, string>,
  customEnumNames: Set<string>
): string[] {
  const lines: string[] = [];
  for (const name of [...refs].sort()) {
    if (customEnumNames.has(name)) {
      lines.push(`import type { ${name} } from "./${name}.js";`);
    } else {
      const fw = sdkEnumFrameworkMap.get(name);
      if (fw) {
        lines.push(`import type { ${name} } from "objcjs-types/${fw}";`);
      }
    }
  }
  return lines;
}

/**
 * Emit a complete .ts file for a custom class.
 */
function emitCustomClassFile(
  cls: ObjCClass,
  allKnownClasses: Set<string>,
  allKnownProtocols: Set<string>,
  allKnownIntegerEnums: Set<string>,
  allKnownStringEnums: Set<string>,
  sdkClassFrameworkMap: Map<string, string>,
  sdkProtocolFrameworkMap: Map<string, string>,
  sdkEnumFrameworkMap: Map<string, string>,
  customNames: Set<string>,
  customEnumNames: Set<string>,
  allParsedClasses?: Map<string, ObjCClass>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import type { NobjcObject } from "objc-js";`);

  // Class/protocol imports
  const classRefs = collectClassRefs(cls, allKnownClasses, allKnownProtocols);
  lines.push(
    ...emitCustomImports(classRefs, sdkClassFrameworkMap, sdkProtocolFrameworkMap, sdkEnumFrameworkMap, customNames)
  );

  // Struct imports
  const structRefs = collectStructRefs(cls);
  lines.push(...emitCustomStructImports(structRefs));

  // Enum imports
  const enumRefs = collectEnumRefs(cls, allKnownIntegerEnums, allKnownStringEnums);
  lines.push(...emitCustomEnumImports(enumRefs, sdkEnumFrameworkMap, customEnumNames));

  lines.push("");
  lines.push(...emitClassBody(cls, allKnownClasses, allParsedClasses));

  // Protocol conformance via declaration merging (simplified — no conflict detection
  // since we don't have full SDK parsed class data for ancestor signature analysis)
  if (cls.protocols.length > 0) {
    const knownProtos = cls.protocols.filter((p) => allKnownProtocols.has(p));
    if (knownProtos.length > 0) {
      const extendsList = knownProtos.map((p) => `_${p}`).join(", ");
      lines.push(`export interface _${cls.name} extends ${extendsList} {}`);
    }
  }

  lines.push("");
  return lines.join("\n");
}

/**
 * Emit a complete .ts file for a custom protocol.
 */
function emitCustomProtocolFile(
  proto: ObjCProtocol,
  allKnownClasses: Set<string>,
  allKnownProtocols: Set<string>,
  allKnownIntegerEnums: Set<string>,
  allKnownStringEnums: Set<string>,
  sdkClassFrameworkMap: Map<string, string>,
  sdkProtocolFrameworkMap: Map<string, string>,
  sdkEnumFrameworkMap: Map<string, string>,
  customNames: Set<string>,
  customEnumNames: Set<string>
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push(`import type { NobjcObject } from "objc-js";`);

  // Class/protocol imports
  const classRefs = collectProtocolClassRefs(proto, allKnownClasses, allKnownProtocols);
  lines.push(
    ...emitCustomImports(classRefs, sdkClassFrameworkMap, sdkProtocolFrameworkMap, sdkEnumFrameworkMap, customNames)
  );

  // Struct imports
  const structRefs = collectProtocolStructRefs(proto);
  lines.push(...emitCustomStructImports(structRefs));

  // Enum imports
  const enumRefs = collectProtocolEnumRefs(proto, allKnownIntegerEnums, allKnownStringEnums);
  lines.push(...emitCustomEnumImports(enumRefs, sdkEnumFrameworkMap, customEnumNames));

  lines.push("");

  // Extends clause
  const extendsClauses: string[] = [];
  for (const ext of proto.extendedProtocols) {
    if (allKnownProtocols.has(ext)) {
      extendsClauses.push(`_${ext}`);
    }
  }
  const extendsStr = extendsClauses.length > 0 ? ` extends ${extendsClauses.join(", ")}` : "";

  lines.push(`export interface _${proto.name}${extendsStr} {`);

  // Instance properties
  const instanceProps = proto.properties.filter((p) => !p.isClassProperty);
  const instancePropertyNames = new Set(instanceProps.map((p) => p.name));
  const regularMethods = proto.instanceMethods.filter((m) => !instancePropertyNames.has(m.selector));

  // Instance methods (optional)
  if (regularMethods.length > 0) {
    lines.push("  // Instance methods");
    for (const method of regularMethods) {
      const jsName = selectorToJS(method.selector);
      const returnType = mapReturnType(method.returnType, proto.name);
      const params: string[] = [];
      const seenNames = new Map<string, number>();
      for (const param of method.parameters) {
        const tsType = mapParamType(param.type, proto.name);
        let safeName = sanitizeParamName(param.name);
        const prev = seenNames.get(safeName) ?? 0;
        seenNames.set(safeName, prev + 1);
        if (prev > 0) {
          safeName = `${safeName}${prev + 1}`;
        }
        params.push(`${safeName}: ${tsType}`);
      }
      lines.push(`  ${jsName}?(${params.join(", ")}): ${returnType};`);
    }
  }

  // Instance properties (optional getters)
  if (instanceProps.length > 0) {
    if (regularMethods.length > 0) lines.push("");
    lines.push("  // Properties");
    for (const prop of instanceProps) {
      const tsType = mapReturnType(prop.type, proto.name);
      lines.push(`  ${prop.name}?(): ${tsType};`);
      if (!prop.readonly) {
        const setterName = `set${prop.name[0]!.toUpperCase()}${prop.name.slice(1)}$`;
        const paramType = mapParamType(prop.type, proto.name);
        lines.push(`  ${setterName}?(value: ${paramType}): void;`);
      }
    }
  }

  lines.push("}");
  lines.push("");
  return lines.join("\n");
}

/**
 * Emit the barrel index.ts for the custom output directory.
 */
function emitCustomIndex(
  classNames: string[],
  protocolNames: string[],
  integerEnumNames: string[],
  stringEnumNames: string[]
): string {
  const lines: string[] = [];
  lines.push(AUTOGEN_HEADER);
  lines.push("");

  for (const name of classNames.sort()) {
    lines.push(`export type { _${name} } from "./${name}.js";`);
  }
  for (const name of protocolNames.sort()) {
    lines.push(`export type { _${name} } from "./${name}.js";`);
  }
  for (const name of integerEnumNames.sort()) {
    lines.push(`export { ${name} } from "./${name}.js";`);
  }
  for (const name of stringEnumNames.sort()) {
    lines.push(`export { ${name} } from "./${name}.js";`);
  }

  lines.push("");
  return lines.join("\n");
}

// ============================================================================
// Main pipeline
// ============================================================================

async function main(): Promise<void> {
  console.log("=== objcjs-types custom generator ===\n");
  const globalStart = performance.now();

  const { headerPaths, includes, includeDirs, defines } = parseArgs();
  console.log(`Input headers: ${headerPaths.map((h) => basename(h)).join(", ")}`);
  if (includes.length > 0) console.log(`Extra includes: ${includes.join(", ")}`);
  if (includeDirs.length > 0) console.log(`Include dirs: ${includeDirs.join(", ")}`);
  if (defines.length > 0) console.log(`Defines: ${defines.join(", ")}`);
  console.log("");

  // ========================================
  // Phase 1: SDK Discovery (populate type-mapper state)
  // ========================================
  console.log("Phase 1: Discovering SDK frameworks...");
  const allBases = await discoverAllFrameworks();
  console.log(`  Found ${allBases.length} frameworks with headers`);

  const frameworks: FrameworkConfig[] = [];
  const discoveryResults = await Promise.all(
    allBases.map(async (base) => {
      const discovery = await discoverFramework(base.headersPath);
      return { base, discovery };
    })
  );

  for (const { base, discovery } of discoveryResults) {
    // Filter out protocols whose names clash with class names
    for (const protoName of discovery.protocols.keys()) {
      if (discovery.classes.has(protoName)) {
        discovery.protocols.delete(protoName);
      }
    }

    // Add extraHeaders classes
    if (base.extraHeaders) {
      for (const className of Object.keys(base.extraHeaders)) {
        if (!discovery.classes.has(className)) {
          discovery.classes.set(className, className);
        }
      }
    }

    if (
      discovery.classes.size === 0 &&
      discovery.protocols.size === 0 &&
      discovery.integerEnums.size === 0 &&
      discovery.stringEnums.size === 0
    )
      continue;

    frameworks.push({
      ...base,
      classes: [...discovery.classes.keys()].sort(),
      protocols: [...discovery.protocols.keys()].sort(),
      integerEnums: [...discovery.integerEnums.keys()].sort(),
      stringEnums: [...discovery.stringEnums.keys()].sort(),
      classHeaders: discovery.classes,
      protocolHeaders: discovery.protocols,
      integerEnumHeaders: discovery.integerEnums,
      stringEnumHeaders: discovery.stringEnums
    });
  }

  // Build SDK lookup maps
  const sdkClassFrameworkMap = new Map<string, string>();
  const sdkProtocolFrameworkMap = new Map<string, string>();
  const sdkEnumFrameworkMap = new Map<string, string>();

  const allKnownClasses = new Set<string>();
  const allKnownProtocols = new Set<string>();
  const allKnownIntegerEnums = new Set<string>();
  const allKnownStringEnums = new Set<string>();

  for (const fw of frameworks) {
    for (const cls of fw.classes) {
      allKnownClasses.add(cls);
      sdkClassFrameworkMap.set(cls, fw.name);
    }
    for (const proto of fw.protocols) {
      allKnownProtocols.add(proto);
      sdkProtocolFrameworkMap.set(proto, fw.name);
    }
    for (const name of fw.integerEnums) {
      allKnownIntegerEnums.add(name);
      sdkEnumFrameworkMap.set(name, fw.name);
    }
    for (const name of fw.stringEnums) {
      allKnownStringEnums.add(name);
      sdkEnumFrameworkMap.set(name, fw.name);
    }
  }

  const discoveryTime = ((performance.now() - globalStart) / 1000).toFixed(1);
  console.log(`  SDK discovery completed in ${discoveryTime}s\n`);

  // ========================================
  // Phase 2: Discover custom headers
  // ========================================
  console.log("Phase 2: Scanning custom headers...");
  const customDiscovery = await discoverCustomHeaders(headerPaths);
  console.log(
    `  Found ${customDiscovery.classes.size} classes, ${customDiscovery.protocols.size} protocols, ` +
      `${customDiscovery.integerEnums.size + customDiscovery.stringEnums.size} enums`
  );

  if (
    customDiscovery.classes.size === 0 &&
    customDiscovery.protocols.size === 0 &&
    customDiscovery.integerEnums.size === 0 &&
    customDiscovery.stringEnums.size === 0
  ) {
    console.error("\nNo ObjC classes, protocols, or enums found in the provided headers.");
    process.exit(1);
  }

  // Add custom names to the global known sets so the type-mapper resolves them
  const customNames = new Set<string>([...customDiscovery.classes, ...customDiscovery.protocols]);
  const customEnumNames = new Set<string>([...customDiscovery.integerEnums, ...customDiscovery.stringEnums]);

  for (const name of customDiscovery.classes) allKnownClasses.add(name);
  for (const name of customDiscovery.protocols) allKnownProtocols.add(name);
  for (const name of customDiscovery.integerEnums) allKnownIntegerEnums.add(name);
  for (const name of customDiscovery.stringEnums) allKnownStringEnums.add(name);

  // Set global type-mapper state
  setKnownClasses(allKnownClasses);
  setKnownProtocols(allKnownProtocols);
  setKnownIntegerEnums(allKnownIntegerEnums);
  setKnownStringEnums(allKnownStringEnums);
  // Empty conformers — we don't need return type union expansion for custom headers
  setProtocolConformers(new Map());

  // ========================================
  // Phase 3: Clang AST parsing
  // ========================================
  console.log("\nPhase 3: Parsing custom headers via clang...");

  // Build extra clang args for -I include dirs, --include headers, and -D defines
  const extraArgs: string[] = [];
  for (const dir of includeDirs) {
    extraArgs.push("-I", resolve(dir));
  }
  for (const inc of includes) {
    extraArgs.push("-include", inc);
  }
  for (const def of defines) {
    extraArgs.push(`-D${def}`);
  }

  const preIncludes = ["Foundation/Foundation.h"];
  const parseStart = performance.now();
  const ast = await clangBatchASTDump(headerPaths, preIncludes, extraArgs.length > 0 ? extraArgs : undefined);

  // Propagate source file locations through the AST
  propagateLocFile(ast);

  // Parse structs and typedefs from the AST (these include SDK types via Foundation pre-include)
  const { structs: parsedStructs, aliases: parsedAliases } = parseStructs(ast);
  const parsedTypedefs = parseTypedefs(ast);

  // Register struct/typedef state so type-mapper can resolve struct types
  const structNames = new Set(parsedStructs.keys());
  const aliasMap = new Map(parsedAliases.map((a) => [a.name, a.target]));
  const internalNameMap = new Map<string, string>();
  for (const [name, structDef] of parsedStructs) {
    if (structDef.internalName) {
      internalNameMap.set(name, structDef.internalName);
    }
  }
  setKnownStructs(structNames, aliasMap, internalNameMap);
  setKnownTypedefs(parsedTypedefs);

  // Parse classes, protocols, and enums from the custom headers
  const parsedClasses = parseAST(ast, customDiscovery.classes);
  const parsedProtocols = parseProtocols(ast, customDiscovery.protocols);
  const parsedIntegerEnums = parseIntegerEnums(ast, customDiscovery.integerEnums);
  const parsedStringEnums = parseStringEnums(ast, customDiscovery.stringEnums);

  const parseTime = ((performance.now() - parseStart) / 1000).toFixed(1);
  console.log(
    `  Parsed ${parsedClasses.size} classes, ${parsedProtocols.size} protocols, ` +
      `${parsedIntegerEnums.size + parsedStringEnums.size} enums in ${parseTime}s`
  );

  // ========================================
  // Phase 4: Emit .ts files
  // ========================================
  console.log("\nPhase 4: Emitting TypeScript declarations...");

  // Clean and create output directory
  if (existsSync(OUTPUT_DIR)) {
    await rm(OUTPUT_DIR, { recursive: true });
  }
  await mkdir(OUTPUT_DIR, { recursive: true });

  let filesWritten = 0;

  // Emit class files
  for (const [name, cls] of parsedClasses) {
    const content = emitCustomClassFile(
      cls,
      allKnownClasses,
      allKnownProtocols,
      allKnownIntegerEnums,
      allKnownStringEnums,
      sdkClassFrameworkMap,
      sdkProtocolFrameworkMap,
      sdkEnumFrameworkMap,
      customNames,
      customEnumNames,
      parsedClasses
    );
    await writeFile(join(OUTPUT_DIR, `${name}.ts`), content);
    filesWritten++;
    console.log(`  ${name}.ts (class)`);
  }

  // Emit protocol files
  for (const [name, proto] of parsedProtocols) {
    const content = emitCustomProtocolFile(
      proto,
      allKnownClasses,
      allKnownProtocols,
      allKnownIntegerEnums,
      allKnownStringEnums,
      sdkClassFrameworkMap,
      sdkProtocolFrameworkMap,
      sdkEnumFrameworkMap,
      customNames,
      customEnumNames
    );
    await writeFile(join(OUTPUT_DIR, `${name}.ts`), content);
    filesWritten++;
    console.log(`  ${name}.ts (protocol)`);
  }

  // Emit integer enum files
  for (const [name, enumDef] of parsedIntegerEnums) {
    const content = emitIntegerEnumFile(enumDef);
    await writeFile(join(OUTPUT_DIR, `${name}.ts`), content);
    filesWritten++;
    console.log(`  ${name}.ts (integer enum)`);
  }

  // Emit string enum files
  for (const [name, enumDef] of parsedStringEnums) {
    const content = emitStringEnumFile(enumDef, "custom");
    await writeFile(join(OUTPUT_DIR, `${name}.ts`), content);
    filesWritten++;
    console.log(`  ${name}.ts (string enum)`);
  }

  // Emit barrel index
  const indexContent = emitCustomIndex(
    [...parsedClasses.keys()],
    [...parsedProtocols.keys()],
    [...parsedIntegerEnums.keys()],
    [...parsedStringEnums.keys()]
  );
  await writeFile(join(OUTPUT_DIR, "index.ts"), indexContent);
  filesWritten++;
  console.log(`  index.ts (barrel)`);

  const totalTime = ((performance.now() - globalStart) / 1000).toFixed(1);
  console.log(`\nDone! Wrote ${filesWritten} files to ${OUTPUT_DIR} in ${totalTime}s`);
}

main().catch((err) => {
  console.error("Fatal error:", err);
  process.exit(1);
});
