// AUTO-GENERATED by objcjs-types generator â€” DO NOT EDIT
import type { NobjcObject } from "objc-js";
import type { _NSFont } from "./NSFont.js";
import type { _NSLayoutManager } from "./NSLayoutManager.js";
import type { _NSTextContainer } from "./NSTextContainer.js";
import type { _NSTextTab } from "./NSTextTab.js";
import type { _NSTypesetter } from "./NSTypesetter.js";
import type { _NSAttributedString } from "../Foundation/NSAttributedString.js";
import type { CGPoint, CGRect, NSRange } from "../structs.js";

export declare class _NSATSTypesetter extends _NSTypesetter {
  static alloc(): _NSATSTypesetter;
  static new(): _NSATSTypesetter;
  init(): _NSATSTypesetter;
  // Class methods
  static sharedTypesetter(): _NSATSTypesetter;

  // Instance methods
  lineFragmentRectForProposedRect$remainingRect$(proposedRect: CGRect, remainingRect: NobjcObject): CGRect;
  substituteFontForFont$(originalFont: _NSFont): _NSFont;
  textTabForGlyphLocation$writingDirection$maxLocation$(glyphLocation: number, direction: number, maxLocation: number): _NSTextTab | null;
  setParagraphGlyphRange$separatorGlyphRange$(paragraphRange: NSRange, paragraphSeparatorRange: NSRange): void;
  layoutParagraphAtPoint$(lineFragmentOrigin: NobjcObject): number;
  lineSpacingAfterGlyphAtIndex$withProposedLineFragmentRect$(glyphIndex: number, rect: CGRect): number;
  paragraphSpacingBeforeGlyphAtIndex$withProposedLineFragmentRect$(glyphIndex: number, rect: CGRect): number;
  paragraphSpacingAfterGlyphAtIndex$withProposedLineFragmentRect$(glyphIndex: number, rect: CGRect): number;
  setHardInvalidation$forGlyphRange$(flag: boolean, glyphRange: NSRange): void;
  getLineFragmentRect$usedRect$forParagraphSeparatorGlyphRange$atProposedOrigin$(lineFragmentRect: NobjcObject, lineFragmentUsedRect: NobjcObject, paragraphSeparatorGlyphRange: NSRange, lineOrigin: CGPoint): void;
  willSetLineFragmentRect$forGlyphRange$usedRect$baselineOffset$(lineRect: NobjcObject, glyphRange: NSRange, usedRect: NobjcObject, baselineOffset: NobjcObject): void;
  shouldBreakLineByWordBeforeCharacterAtIndex$(charIndex: number): boolean;
  shouldBreakLineByHyphenatingBeforeCharacterAtIndex$(charIndex: number): boolean;
  hyphenationFactorForGlyphAtIndex$(glyphIndex: number): number;
  hyphenCharacterForGlyphAtIndex$(glyphIndex: number): NobjcObject;
  boundingBoxForControlGlyphAtIndex$forTextContainer$proposedLineFragment$glyphPosition$characterIndex$(glyphIndex: number, textContainer: _NSTextContainer, proposedRect: CGRect, glyphPosition: CGPoint, charIndex: number): CGRect;
  getGlyphsInRange$glyphs$characterIndexes$glyphInscriptions$elasticBits$(glyphsRange: NSRange, glyphBuffer: NobjcObject, charIndexBuffer: NobjcObject, inscribeBuffer: NobjcObject, elasticBuffer: NobjcObject): number;

  // Properties
  usesFontLeading(): boolean;
  setUsesFontLeading$(value: boolean): void;
  typesetterBehavior(): number;
  setTypesetterBehavior$(value: number): void;
  hyphenationFactor(): number;
  setHyphenationFactor$(value: number): void;
  lineFragmentPadding(): number;
  setLineFragmentPadding$(value: number): void;
  bidiProcessingEnabled(): boolean;
  setBidiProcessingEnabled$(value: boolean): void;
  attributedString(): _NSAttributedString | null;
  setAttributedString$(value: _NSAttributedString | null): void;
  paragraphGlyphRange(): NSRange;
  paragraphSeparatorGlyphRange(): NSRange;
  layoutManager(): _NSLayoutManager | null;
  currentTextContainer(): _NSTextContainer | null;
}
