// AUTO-GENERATED by objcjs-types generator â€” DO NOT EDIT
import type { NobjcObject } from "objc-js";
import type { _NSArray } from "./NSArray.js";
import type { _NSData } from "./NSData.js";
import type { _NSDictionary } from "./NSDictionary.js";
import type { _NSObject } from "./NSObject.js";
import type { _NSString } from "./NSString.js";
import type { _NSURL } from "./NSURL.js";

export declare class _NSFileManager extends _NSObject {
  static alloc(): _NSFileManager;
  static new(): _NSFileManager;
  init(): _NSFileManager;
  // Class methods
  static defaultManager(): _NSFileManager;

  // Instance methods
  mountedVolumeURLsIncludingResourceValuesForKeys$options$(propertyKeys: _NSArray | null, options: number): _NSArray | null;
  unmountVolumeAtURL$options$completionHandler$(url: _NSURL, mask: number, completionHandler: (...args: any[]) => any | null): void;
  contentsOfDirectoryAtURL$includingPropertiesForKeys$options$error$(url: _NSURL, keys: _NSArray | null, mask: number, error: NobjcObject): _NSArray | null;
  URLsForDirectory$inDomains$(directory: number, domainMask: number): _NSArray;
  URLForDirectory$inDomain$appropriateForURL$create$error$(directory: number, domain: number, url: _NSURL | null, shouldCreate: boolean, error: NobjcObject): _NSURL | null;
  getRelationship$ofDirectoryAtURL$toItemAtURL$error$(outRelationship: NobjcObject, directoryURL: _NSURL, otherURL: _NSURL, error: NobjcObject): boolean;
  getRelationship$ofDirectory$inDomain$toItemAtURL$error$(outRelationship: NobjcObject, directory: number, domainMask: number, url: _NSURL, error: NobjcObject): boolean;
  createDirectoryAtURL$withIntermediateDirectories$attributes$error$(url: _NSURL, createIntermediates: boolean, attributes: _NSDictionary | null, error: NobjcObject): boolean;
  createSymbolicLinkAtURL$withDestinationURL$error$(url: _NSURL, destURL: _NSURL, error: NobjcObject): boolean;
  setAttributes$ofItemAtPath$error$(attributes: _NSDictionary, path: _NSString, error: NobjcObject): boolean;
  createDirectoryAtPath$withIntermediateDirectories$attributes$error$(path: _NSString, createIntermediates: boolean, attributes: _NSDictionary | null, error: NobjcObject): boolean;
  contentsOfDirectoryAtPath$error$(path: _NSString, error: NobjcObject): _NSArray | null;
  subpathsOfDirectoryAtPath$error$(path: _NSString, error: NobjcObject): _NSArray | null;
  attributesOfItemAtPath$error$(path: _NSString, error: NobjcObject): _NSDictionary | null;
  attributesOfFileSystemForPath$error$(path: _NSString, error: NobjcObject): _NSDictionary | null;
  createSymbolicLinkAtPath$withDestinationPath$error$(path: _NSString, destPath: _NSString, error: NobjcObject): boolean;
  destinationOfSymbolicLinkAtPath$error$(path: _NSString, error: NobjcObject): _NSString | null;
  copyItemAtPath$toPath$error$(srcPath: _NSString, dstPath: _NSString, error: NobjcObject): boolean;
  moveItemAtPath$toPath$error$(srcPath: _NSString, dstPath: _NSString, error: NobjcObject): boolean;
  linkItemAtPath$toPath$error$(srcPath: _NSString, dstPath: _NSString, error: NobjcObject): boolean;
  removeItemAtPath$error$(path: _NSString, error: NobjcObject): boolean;
  copyItemAtURL$toURL$error$(srcURL: _NSURL, dstURL: _NSURL, error: NobjcObject): boolean;
  moveItemAtURL$toURL$error$(srcURL: _NSURL, dstURL: _NSURL, error: NobjcObject): boolean;
  linkItemAtURL$toURL$error$(srcURL: _NSURL, dstURL: _NSURL, error: NobjcObject): boolean;
  removeItemAtURL$error$(URL: _NSURL, error: NobjcObject): boolean;
  trashItemAtURL$resultingItemURL$error$(url: _NSURL, outResultingURL: NobjcObject, error: NobjcObject): boolean;
  fileAttributesAtPath$traverseLink$(path: _NSString, yorn: boolean): _NSDictionary | null;
  changeFileAttributes$atPath$(attributes: _NSDictionary, path: _NSString): boolean;
  directoryContentsAtPath$(path: _NSString): _NSArray | null;
  fileSystemAttributesAtPath$(path: _NSString): _NSDictionary | null;
  pathContentOfSymbolicLinkAtPath$(path: _NSString): _NSString | null;
  createSymbolicLinkAtPath$pathContent$(path: _NSString, otherpath: _NSString): boolean;
  createDirectoryAtPath$attributes$(path: _NSString, attributes: _NSDictionary): boolean;
  linkPath$toPath$handler$(src: _NSString, dest: _NSString, handler: NobjcObject): boolean;
  copyPath$toPath$handler$(src: _NSString, dest: _NSString, handler: NobjcObject): boolean;
  movePath$toPath$handler$(src: _NSString, dest: _NSString, handler: NobjcObject): boolean;
  removeFileAtPath$handler$(path: _NSString, handler: NobjcObject): boolean;
  changeCurrentDirectoryPath$(path: _NSString): boolean;
  fileExistsAtPath$(path: _NSString): boolean;
  fileExistsAtPath$isDirectory$(path: _NSString, isDirectory: NobjcObject): boolean;
  isReadableFileAtPath$(path: _NSString): boolean;
  isWritableFileAtPath$(path: _NSString): boolean;
  isExecutableFileAtPath$(path: _NSString): boolean;
  isDeletableFileAtPath$(path: _NSString): boolean;
  contentsEqualAtPath$andPath$(path1: _NSString, path2: _NSString): boolean;
  displayNameAtPath$(path: _NSString): _NSString;
  componentsToDisplayForPath$(path: _NSString): _NSArray | null;
  enumeratorAtPath$(path: _NSString): NobjcObject;
  enumeratorAtURL$includingPropertiesForKeys$options$errorHandler$(url: _NSURL, keys: _NSArray | null, mask: number, handler: (...args: any[]) => any | null): NobjcObject;
  subpathsAtPath$(path: _NSString): _NSArray | null;
  contentsAtPath$(path: _NSString): _NSData | null;
  createFileAtPath$contents$attributes$(path: _NSString, data: _NSData | null, attr: _NSDictionary | null): boolean;
  fileSystemRepresentationWithPath$(path: _NSString): string;
  stringWithFileSystemRepresentation$length$(str: string, len: number): _NSString;
  replaceItemAtURL$withItemAtURL$backupItemName$options$resultingItemURL$error$(originalItemURL: _NSURL, newItemURL: _NSURL, backupItemName: _NSString | null, options: number, resultingURL: NobjcObject, error: NobjcObject): boolean;
  setUbiquitous$itemAtURL$destinationURL$error$(flag: boolean, url: _NSURL, destinationURL: _NSURL, error: NobjcObject): boolean;
  isUbiquitousItemAtURL$(url: _NSURL): boolean;
  startDownloadingUbiquitousItemAtURL$error$(url: _NSURL, error: NobjcObject): boolean;
  evictUbiquitousItemAtURL$error$(url: _NSURL, error: NobjcObject): boolean;
  URLForUbiquityContainerIdentifier$(containerIdentifier: _NSString | null): _NSURL | null;
  URLForPublishingUbiquitousItemAtURL$expirationDate$error$(url: _NSURL, outDate: NobjcObject, error: NobjcObject): _NSURL | null;
  pauseSyncForUbiquitousItemAtURL$completionHandler$(url: _NSURL, completionHandler: (...args: any[]) => any | null): void;
  resumeSyncForUbiquitousItemAtURL$withBehavior$completionHandler$(url: _NSURL, behavior: number, completionHandler: (...args: any[]) => any | null): void;
  fetchLatestRemoteVersionOfItemAtURL$completionHandler$(url: _NSURL, completionHandler: (...args: any[]) => any | null): void;
  uploadLocalVersionOfUbiquitousItemAtURL$withConflictResolutionPolicy$completionHandler$(url: _NSURL, conflictResolutionPolicy: number, completionHandler: (...args: any[]) => any | null): void;
  getFileProviderServicesForItemAtURL$completionHandler$(url: _NSURL, completionHandler: (...args: any[]) => any | null): void;
  containerURLForSecurityApplicationGroupIdentifier$(groupIdentifier: _NSString): _NSURL | null;
  homeDirectoryForUser$(userName: _NSString): _NSURL | null;

  // Properties
  delegate(): NobjcObject;
  setDelegate$(value: NobjcObject): void;
  currentDirectoryPath(): _NSString;
  ubiquityIdentityToken(): NobjcObject;
  homeDirectoryForCurrentUser(): NobjcObject;
  temporaryDirectory(): _NSURL;
}
